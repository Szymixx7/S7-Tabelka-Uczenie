<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<title>Trening S≈Ç√≥wek z Tabelki by Szymix7üëë v7.1</title>
<style>
:root {
    --bg-1: #091425;
    --bg-2: #111b31;
    --glass: rgba(255, 255, 255, 0.08);
    --glass-strong: rgba(255, 255, 255, 0.14);
    --line: rgba(255, 255, 255, 0.16);
    --text: #eaf0ff;
    --muted: #a8b5d7;
    --main: #13b7ff;
    --danger: #ff4d7d;
    --secondary: #8aa2ff;
}
* { box-sizing: border-box; }
body {
    font-family: "Segoe UI", "Trebuchet MS", Arial, sans-serif;
    margin: 20px;
    color: var(--text);
    background:
        radial-gradient(900px 500px at 8% -10%, rgba(19,183,255,0.22), transparent 60%),
        radial-gradient(900px 500px at 95% -5%, rgba(255,77,125,0.2), transparent 58%),
        linear-gradient(150deg, var(--bg-1), var(--bg-2));
    min-height: 100vh;
}
h2 { margin-top: 0; letter-spacing: 0.3px; text-shadow: 0 0 24px rgba(19,183,255,0.25); }
textarea, input[type="number"], input[type="text"], input[type="file"] {
    border: 1px solid var(--line);
    color: var(--text);
    background: var(--glass);
    backdrop-filter: blur(8px);
    border-radius: 12px;
}
textarea {
    width: 100%;
    height: 150px;
    padding: 12px;
}
input {
    width: 95%;
    border: none;
    text-align: center;
    padding: 7px;
    border-radius: 8px;
    color: var(--text);
    background: rgba(7, 15, 30, 0.65);
}
table {
    border-collapse: separate;
    border-spacing: 0;
    margin-top: 15px;
    width: 100%;
    border: 1px solid var(--line);
    background: var(--glass);
    backdrop-filter: blur(12px);
    border-radius: 14px;
    overflow: hidden;
}
td, th {
    border: 1px solid rgba(255, 255, 255, 0.08);
    padding: 8px;
    text-align: center;
    min-width: 100px;
    transition: transform .18s ease, box-shadow .18s ease, background .18s ease;
}
td:hover { transform: translateY(-1px); box-shadow: inset 0 0 0 1px rgba(19,183,255,0.35); }
.fixed { background: rgba(255, 170, 35, 0.75) !important; color: #fff; }
.info { background: rgba(255, 98, 177, 0.68) !important; }
.discovered { background: rgba(81, 175, 255, 0.7) !important; }
.correct { background: rgba(68, 211, 142, 0.75) !important; }
.wrong { background: rgba(255, 91, 91, 0.78) !important; }
.toDiscover { outline: 2px solid #70ddff; }
.btn {
    margin: 5px;
    padding: 9px 14px;
    cursor: pointer;
    border: 1px solid var(--line);
    border-radius: 12px;
    position: relative;
    isolation: isolate;
    overflow: hidden;
    color: #fff;
    background:
        linear-gradient(165deg, rgba(255,255,255,0.24), rgba(255,255,255,0.06) 55%),
        var(--glass);
    backdrop-filter: saturate(170%) blur(14px);
    -webkit-backdrop-filter: saturate(170%) blur(14px);
    transition: transform .2s ease, box-shadow .2s ease, border-color .2s ease;
}
.btn::before {
    content: "";
    position: absolute;
    left: 8%;
    right: 8%;
    top: -45%;
    height: 80%;
    border-radius: 999px;
    background: linear-gradient(to bottom, rgba(255,255,255,0.65), rgba(255,255,255,0));
    opacity: .55;
    pointer-events: none;
}
.btn::after {
    content: "";
    position: absolute;
    inset: 0;
    border-radius: 10px;
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.38), inset 0 -10px 30px rgba(0,0,0,0.15);
    pointer-events: none;
}
.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 24px rgba(0,0,0,.22), 0 0 18px rgba(19,183,255,.28);
    border-color: rgba(255, 255, 255, 0.4);
}
.btn-main { box-shadow: 0 0 14px rgba(19,183,255,0.25); }
.btn-danger { box-shadow: 0 0 14px rgba(255,77,125,0.3); }
.btn-secondary { box-shadow: 0 0 14px rgba(138,162,255,0.28); }
.btn.active {
    border-color: rgba(105,229,255,0.95);
    box-shadow: 0 0 0 1px rgba(105,229,255,0.55), 0 0 20px rgba(19,183,255,0.6), 0 8px 24px rgba(0,0,0,.35);
    transform: translateY(-1px);
}
.topTools { display:flex; justify-content:flex-end; margin-bottom:10px; }
.quizCellSelected { outline: 2px solid #ffe66d !important; box-shadow: inset 0 0 0 1px rgba(255,230,109,0.75), 0 0 16px rgba(255,230,109,0.45); }
.settingsBtn {
    width: 100%;
    margin: 0;
    padding: 12px 14px;
    text-align: center;
    font-size: 15px;
}
.settingsStack {
    display: grid;
    gap: 10px;
    margin-top: 12px;
}
.settingsSelect {
    width: 100%;
    margin: 0;
    padding: 12px 14px;
    border-radius: 12px;
    border: 1px solid var(--line);
    background: var(--glass);
    color: var(--text);
    backdrop-filter: saturate(170%) blur(10px);
}
.settingsSelect option {
    color: #111;
    background: #fff;
}
.settingsLabel {
    font-size: 13px;
    color: var(--muted);
    margin: 4px 0 2px;
}
.shortcutMask {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.58);
    z-index: 12550;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 14px;
}
.shortcutMaskBox {
    max-width: 620px;
    border: 1px solid var(--line);
    border-radius: 12px;
    background: rgba(10, 18, 34, 0.94);
    padding: 14px;
}
body.theme-black {
    --bg-1: #050505;
    --bg-2: #151515;
    --glass: rgba(255, 255, 255, 0.05);
    --line: rgba(255, 255, 255, 0.14);
    --text: #eceff5;
    --muted: #b9c0cc;
    background:
        radial-gradient(900px 500px at 8% -10%, rgba(255,255,255,0.08), transparent 60%),
        linear-gradient(150deg, var(--bg-1), var(--bg-2));
}
body.theme-white {
    --bg-1: #f7f9ff;
    --bg-2: #e9eef7;
    --glass: rgba(255, 255, 255, 0.85);
    --line: rgba(16, 24, 40, 0.2);
    --text: #1a2335;
    --muted: #34425f;
    --main: #0b72ff;
    --danger: #e0466b;
    --secondary: #5a76d8;
    background:
        radial-gradient(900px 500px at 8% -10%, rgba(11,114,255,0.12), transparent 60%),
        linear-gradient(150deg, var(--bg-1), var(--bg-2));
}
body.theme-white .btn {
    color: #1a2335;
    border-color: rgba(16, 24, 40, 0.25);
}
body.theme-white .btn-danger {
    color: #fff;
}
body.theme-white .timerOverlay .lockBtn {
    color: #1a2335;
}
body.theme-purple {
    --bg-1: #223e84;
    --bg-2: #6f3a8a;
    --glass: rgba(255, 255, 255, 0.09);
    --line: rgba(255, 255, 255, 0.18);
    --text: #f2eefe;
    --muted: #d2c5f6;
    background:
        radial-gradient(900px 500px at 8% -10%, rgba(108,207,255,0.33), transparent 60%),
        radial-gradient(900px 500px at 95% -5%, rgba(255,138,236,0.3), transparent 58%),
        linear-gradient(150deg, var(--bg-1), var(--bg-2));
}
body.no-liquid .btn::before,
body.no-liquid .btn::after { display: none; }
body.no-liquid .btn {
    background: rgba(255,255,255,0.12);
    border-color: rgba(255,255,255,0.26);
    backdrop-filter: none;
    -webkit-backdrop-filter: none;
}
#settingsOverlay .dbPanel,
#shortcutsOverlay .dbPanel,
#styleOverlay .dbPanel {
    background: var(--glass) !important;
    border-color: var(--line) !important;
    color: var(--text) !important;
    backdrop-filter: saturate(170%) blur(14px);
    -webkit-backdrop-filter: saturate(170%) blur(14px);
}
#hintOverlay > div,
#statsOverlay > div {
    background: var(--glass) !important;
    border: 1px solid var(--line) !important;
    color: var(--text) !important;
    backdrop-filter: saturate(170%) blur(14px);
    -webkit-backdrop-filter: saturate(170%) blur(14px);
}
#hintOverlay,
#statsOverlay,
#settingsOverlay,
#shortcutsOverlay,
#styleOverlay {
    color: var(--text) !important;
}
@keyframes spinRing { to { transform: rotate(360deg); } }
#controls {
    margin-top: 15px;
    padding: 12px;
    border: 1px solid var(--line);
    border-radius: 14px;
    background: var(--glass);
    backdrop-filter: blur(10px);
}
#extraText { height: 90px; margin-top: 10px; }
#extraTextDisplay {
    white-space: pre-wrap;
    background: var(--glass);
    color: var(--text);
    padding: 10px;
    border: 1px solid var(--line);
    border-radius: 12px;
    margin-top: 10px;
    min-height: 60px;
}
.timerOverlay {
    position: fixed;
    right: 20px;
    top: 80px;
    background: rgba(11, 19, 36, 0.82);
    color: #fff;
    padding:10px 12px;
    border: 1px solid var(--line);
    border-radius: 10px;
    backdrop-filter: blur(8px);
    z-index:9999;
    cursor: move;
    user-select:none;
}
.timerOverlay.locked { cursor: default; }
.timerOverlay .lockBtn { background:transparent; border:none; color:white; font-size:16px; margin-left:8px; cursor:pointer; }
.editorSelected { outline: 3px solid #007bff; }
.editorModeLabel { margin: 8px 0; font-weight: bold; }
.hintMeta { margin-top: 6px; font-size: 12px; color: #112; background: #d7fff0; padding: 4px 6px; border-radius: 6px; }
.hintCombined { margin-top: 6px; display: flex; flex-wrap: wrap; gap: 4px; justify-content: center; }
.hintSquare { width: 18px; height: 18px; border: 1px solid #333; display: inline-flex; align-items: center; justify-content: center; font-size: 12px; font-weight: 700; color: #0b1221; cursor: pointer; background: #fff; }
.hintGap { width: 14px; height: 18px; display: inline-block; }
.excludeFixed { box-shadow: inset -6px 0 0 #ffd400; }
.hintBadgeBtn { position:absolute; right:2px; top:2px; width:16px; height:16px; border:none; border-radius:3px; background:#ffd400; cursor:pointer; font-size:11px; line-height:16px; padding:0; }
td.hasHintBadge { position: relative; padding-right: 20px; }
.dbOverlay { position:fixed; inset:0; background:rgba(0,0,0,0.75); z-index:13000; overflow:auto; }
.dbPanel {
    max-width: 900px;
    margin: 30px auto;
    background: rgba(10, 18, 34, 0.92);
    color: var(--text);
    border: 1px solid var(--line);
    border-radius: 14px;
    padding: 14px;
    backdrop-filter: blur(12px);
}
.dbItem {
    border: 1px solid var(--line);
    border-radius: 10px;
    padding: 10px;
    margin: 8px 0;
    background: rgba(255,255,255,0.05);
}
label { color: var(--muted); }
input[type="checkbox"] { accent-color: #58d8ff; }

@media (max-width: 768px){
    body { margin: 10px; }
    .btn { width: calc(50% - 12px); min-width: 140px; }
    input[type="number"] { width: 92px !important; }
    #controls { padding: 10px; }
    td, th { min-width: 86px; padding: 6px; }
}
</style>
</head>
<body>

<h2>Trening S≈Ç√≥wek z Tabelki by Szymix7üëë v7.1</h2>
<div class="topTools">
<button id="bugBtn" class="btn btn-secondary" onclick="openSettingsOverlay()" title="Ustawienia" aria-label="Ustawienia">‚öôÔ∏è</button>
</div>

<textarea id="inputArea" placeholder="Wklej tabelkƒô z Worda..."></textarea><br>
<button class="btn btn-main" onclick="convertTable()">Konwertuj</button>
<button class="btn btn-secondary" onclick="clearAll()">Wyczy≈õƒá</button>
<button class="btn btn-secondary" onclick="exportTable()">Eksportuj tabelƒô</button>
<input type="file" id="importFile" style="display:inline-block;" onchange="importTable(this.files[0])">
<button class="btn btn-secondary" onclick="openDbFilePicker()">Wybierz plik z bazy</button>
<button class="btn btn-secondary" onclick="createTable()">Stw√≥rz tabelƒô</button>
<button class="btn btn-secondary" onclick="editTable()">Edytuj tabelƒô</button>

<label style="display:inline-flex; align-items:center; margin-left:10px; cursor:pointer;">
  <input type="checkbox" id="autoEnter" style="margin:0 5px 0 0;"> Automatyczny Enter
</label>

<label style="display:inline-flex; align-items:center; margin-left:10px; cursor:pointer;">
  <input type="checkbox" id="autoClear" style="margin:0 5px 0 0;" checked> Automatyczne Kasowanie Tekstu
</label>

<label style="display:inline-flex; align-items:center; margin-right:15px;">
  <input type="checkbox" id="shuffleRows" style="margin:0 8px 0 0;" checked> Tasuj wiersze (tylko w te≈õcie)
</label>

<label style="display:inline-flex; align-items:center; margin-left:10px; cursor:pointer;">
  <input type="checkbox" id="showStatsCheckbox" style="margin:0 5px 0 0;" checked> Statystyki
</label>

<div id="controls" style="display:none;">
<p>Opcje:</p>
<button id="modeRandomBtn" class="btn btn-secondary" onclick="setMode('random')">Losowe</button>
<button id="modeFixedBtn" class="btn btn-secondary" onclick="setMode('fixed')">Losowe warto≈õciowe</button>
<input type="number" id="fixedCount" value="-1" style="width:60px; display:inline-block; margin-left:10px;" title="Ile kom√≥rek na linijkƒô zakryƒá"><br><br>
<button id="modeManualBtn" class="btn btn-secondary" onclick="setMode('manual')">Manualne</button>
<button id="modeInfoBtn" class="btn btn-secondary" onclick="setMode('info')">Zaznaczanie informacyjne</button>
<button id="modeExcludeFixedBtn" class="btn btn-secondary" onclick="setMode('excludeFixed')">Ignoruj w losowe warto≈õciowe</button>
<button id="manualSelectBtn" class="btn btn-secondary" onclick="toggleManualSelect()">Manualny tryb wyboru</button><br><br>

Globalna liczba pr√≥b: <input type="number" id="maxTries" value="-1" style="width:60px;"> (-1 = brak limitu)<br>
Ilo≈õƒá pr√≥b na kom√≥rkƒô: <input type="number" id="cellTries" value="-1" style="width:60px;"> (-1 = brak limitu)<br>
Limit czasu (sekundy): <input type="number" id="timeLimit" value="-1" style="width:80px;"> (-1 lub 0 = brak limitu)<br><br>

<button class="btn btn-main" onclick="startQuiz()">Start</button>
</div>

<div id="tableContainer"></div>

<!-- pole tekstowe z pytaniami ‚Äî edytowalne w menu g≈Ç√≥wnym, w quizie pokazujemy tylko display -->
<textarea id="extraText" placeholder="Tu wpisz pytania/opisy (np. jak krzy≈º√≥wka). Edytowalne tylko w menu g≈Ç√≥wnym."></textarea>
<div id="extraTextDisplay" style="display:none"></div>

<div id="quizControls" style="display:none; margin-top:15px;">
<button id="discoverModeBtn" class="btn btn-secondary" onclick="enterDiscoverMode()">Odkryj wybrane</button>
<button id="renewModeBtn" class="btn btn-secondary" onclick="enterRenewMode()">Odn√≥w wybrane</button>
<button id="hintModeBtn" class="btn btn-secondary" onclick="armHintMode()">Podpowied≈∫ (1 klik)</button>
<button class="btn btn-secondary" onclick="showAll()">Poka≈º wszystko</button>
<button id="endQuizBtn" class="btn btn-danger" onclick="endQuiz()">Zako≈Ñcz test</button>
<button id="backBtn" class="btn btn-secondary" onclick="backToMenu()" style="display:inline-block;">Wr√≥ƒá</button>
</div>

<script>
let tableData = [];
let mode = null;
let quizMode = null;
let markMode = null;
let savedConfig = {};
let globalTries = 0;
let maxGlobalExceeded = false;
let discoverMode = false;
let renewMode = false;
let manualSelectMode = false;
let hintModeArmed = false;
let editorMode = null;
let editorSelected = null;
let editorBuffer = [];

let timerInterval = null;
let timerRemaining = 0;
let timerOverlay = null;
let timerLocked = true;
let dragState = { active: false, startX:0, startY:0, initLeft:0, initTop:0 };

function normalize(str){
    return (str||"")
        .toLowerCase()
        .replace(/√§/g,'a')
        .replace(/√∂/g,'o')
        .replace(/√º/g,'u')
        .replace(/√ü/g,'b')
        .replace(/ƒÖ/g,'a')
        .replace(/ƒô/g,'e')
        .replace(/ƒá/g,'c')
        .replace(/≈Ç/g,'l')
        .replace(/≈Ñ/g,'n')
        .replace(/√≥/g,'o')
        .replace(/≈õ/g,'s')
        .replace(/≈º/g,'z')
        .replace(/≈∫/g,'z')
        .trim();
}

function parseAnswerOptions(answer){
    const raw = (answer || "").split(",").map(v => normalize(v)).filter(Boolean);
    return raw.length ? raw : [normalize(answer || "")];
}

function getMarkMap(){
    const marks = {};
    document.querySelectorAll("#tableContainer td").forEach(td=>{
        marks[`${td.dataset.r}-${td.dataset.c}`] = {
            info: td.classList.contains("info"),
            fixed: td.classList.contains("fixed"),
            excludeFixed: td.classList.contains("excludeFixed")
        };
    });
    return marks;
}

function convertTable(){
    let text = document.getElementById("inputArea").value.trim();
    if(!text) return;
    tableData = text.split("\n").map(row=>row.split(/\t/));
    renderTable(true);
    document.getElementById("controls").style.display = "block";
    // ensure extraText editable visible
    document.getElementById("extraText").style.display = "block";
    document.getElementById("extraTextDisplay").style.display = "none";

    // tableData musi pozostaƒá zwyk≈ÇƒÖ tablicƒÖ 2D (bez obiekt√≥w), bo reszta kodu u≈ºywa row.forEach
}

function renderTable(selectable=false){
    let html = "<table>";
    tableData.forEach((row,r)=>{
        html += "<tr>";
        row.forEach((cell,c)=>{
            html += `<td data-r="${r}" data-c="${c}" data-answer="${cell}" onclick="${selectable?'toggleCell(this)':''}">${cell}</td>`;
        });
        html += "</tr>";
    });
    html += "</table>";
    document.getElementById("tableContainer").innerHTML = html;
}

function toggleCell(td){
    if(manualSelectMode) td.classList.toggle("fixed");
    else if(markMode==="info") td.classList.toggle("info");
    else if(markMode==="excludeFixed") td.classList.toggle("excludeFixed");
}

function setMode(m){ mode=m; }

function toggleManualSelect(){
    manualSelectMode = !manualSelectMode;
    updateCellClickHandlers();
}

let quizStartTime = 0;

function startQuiz(){
    quizStartTime = Date.now();
    // --- OSTRZE≈ªENIE O BRAKU ZA≈ÅADOWANEJ TABELI (tylko je≈õli brak pliku) ---
    const fileInput = document.getElementById("importFile");
    if (!fileInput.files.length) {
        alert(
            "Nie masz za≈Çadowanej tabeli!\n\n" +
            "Aby rozpoczƒÖƒá quiz, musisz:\n" +
            "1Ô∏è‚É£ Wyeksportowaƒá tabelƒô,\n" +
            "2Ô∏è‚É£ Za≈Çadowaƒá plik tabeli (.json) za pomocƒÖ przycisku 'Wybierz plik'.\n\n" +
            "Po wykonaniu tych krok√≥w kliknij ponownie 'Start'."
        );
        return; // zatrzymuje uruchamianie quizu
    }

    savedConfig.manualSelectMode = manualSelectMode; // <-- dodaj
    mode = mode === "info" ? null : mode; // wy≈ÇƒÖcza tryb info po starcie
    manualSelectMode = false; // te≈º wy≈ÇƒÖcz manualny tryb wyboru
    manualSelectMode = false;
    if(!mode){ alert("Wybierz tryb!"); return; }

    // save original state (do przywr√≥cenia)
    savedConfig = {
        mode: mode,
        fixedCount: parseInt(document.getElementById("fixedCount").value)||2,
        maxGlobal: parseInt(document.getElementById("maxTries").value)||-1,
        maxCell: parseInt(document.getElementById("cellTries").value)||-1,
        tableState: JSON.parse(JSON.stringify(tableData)), // original
        extraText: document.getElementById("extraText").value || "",
        cellStates: []
    };
    globalTries = 0;
    maxGlobalExceeded = false;

    // prepare quizData as a copy so original tableData not changed
    let quizData = prepareQuizData();
    // shuffle rows only in quiz if user ticked shuffleRows
    if(document.getElementById("shuffleRows").checked){
        quizData.sort(()=>0.5 - Math.random());
    }

    let html = "<table>";
    quizData.forEach((row,r)=>{
        html += "<tr>";
        let indices = row.map((_,i)=>i);
        let fixed=[];
        if(mode==="random") fixed = indices.filter(i=>{
            // origTd based on original rendered table positions might not match after shuffle,
            // but we only want to check if original had info/fixed ‚Äî simpler: check original tableState
            // find corresponding original row index for this row's content (approximate)
            return true; // we'll not rely on origTd for info in shuffled quiz; info/fixed from original tableState should be preserved via class checks later if needed.
        }).sort(()=>0.5-Math.random()).slice(0,Math.floor(Math.random()*3)+1);
        else if(mode==="fixed") fixed = indices.sort(()=>0.5-Math.random()).slice(0,savedConfig.fixedCount);

        row.forEach((cell,c)=>{
            let tdClass="", content="";
            // try find original cell state (info/fixed) by matching value in original tableState
            let origStateClass = ""; // default
            // search in original tableState for same cell value in same row length to guess class ‚Äî but to keep simple we respect only 'info'/'fixed' if they were set in original rendered DOM before startQuiz.
            // Instead, check savedConfig.tableState for existence of same cell in same row index; if shuffle we don't worry ‚Äî user expects info marking preserved on visible table maybe not necessary
            // We'll preserve per-cell 'info' or 'fixed' by checking the currently rendered DOM cells before startQuiz (the original table view still exists in DOM).
            let origTd = document.querySelector(`#tableContainer td[data-answer="${cell}"]`);
            if(origTd && origTd.classList.contains("info")) { tdClass="info"; content = cell; }
            else if(origTd && origTd.classList.contains("fixed") && mode==="manual"){ tdClass="fixed"; content=cell; }
            else if((mode==="manual" && origTd?.classList.contains("fixed"))||fixed.includes(c)){
                tdClass="fixed"; 
                content=cell;
            }
            else{
                let maxCell = savedConfig.maxCell;
                content=`<input data-answer="${cell}" data-tries="0" data-maxtries="${maxCell}" onkeydown="checkInput(event,this)">`;
            }
            html += `<td class="${tdClass}" data-answer="${cell}">${content}</td>`;
        });
        html += "</tr>";
    });
    html += "</table>";
    document.getElementById("tableContainer").innerHTML = html;

    // blokada pustych kom√≥rek w quizie
    document.querySelectorAll("#tableContainer td").forEach(td => {
        if(!td.dataset.answer || td.dataset.answer.trim() === ""){
            td.style.background = "black";
            td.style.color = "white";
            td.innerHTML = ""; // usuwa input
            td.onclick = null;  // blokada klikniƒôƒá
        }
    });

    // show extraText as display (read-only) and hide editable textarea
    document.getElementById("extraTextDisplay").textContent = savedConfig.extraText;
    document.getElementById("extraTextDisplay").style.display = savedConfig.extraText ? "block" : "none";
    document.getElementById("extraText").style.display = "none";

    document.getElementById("quizControls").style.display = "block";
    document.getElementById("controls").style.display = "none";
    updateCellClickHandlers();
    setupAutoEnter();

    // Timer: start only if >0
    const timeLimit = parseInt(document.getElementById("timeLimit").value);
    if(!isNaN(timeLimit) && timeLimit > 0){
        startTimer(timeLimit);
    }

    savedConfig.manualSelectMode = manualSelectMode || false;

    // zapisz tylko 'info' i 'fixed' PRZED startem quizu
    savedConfig.cellStates = [];
    document.querySelectorAll("#tableContainer td").forEach(td=>{
        if(td.classList.contains("info") || td.classList.contains("fixed")){
            savedConfig.cellStates.push({
                r: parseInt(td.dataset.r),
                c: parseInt(td.dataset.c),
                className: td.classList.contains("info") ? "info" : "fixed"
            });
        }
    });

}

function startTimer(seconds){
    stopTimer(); // clear existing if any
    timerRemaining = seconds;
    createTimerOverlay();
    updateTimerOverlay();
    timerInterval = setInterval(()=>{
        timerRemaining--;
        updateTimerOverlay();
        if(timerRemaining <= 0){
    	    stopTimer();
    	    alert("Czas minƒÖ≈Ç! Odpowiedzi zostanƒÖ odkryte.");
    	    showAll(); // zamiast ustawiaƒá wszystkim na wrong
	    // --- wywo≈Çanie statystyk, je≈õli checkbox Statystyki jest w≈ÇƒÖczony ---
	    if (document.getElementById("showStatsCheckbox")?.checked) {
    	        const statsHtml = calculateStats(); // funkcja generujƒÖca tre≈õƒá statystyk
	    	showStatsOverlay(statsHtml); // pokazuje nak≈Çadkƒô
	    }
	}
    }, 1000);
}

function stopTimer(){
    if(timerInterval) { clearInterval(timerInterval); timerInterval = null; }
    if(timerOverlay){ timerOverlay.remove(); timerOverlay = null; }
    dragState.active = false;
    timerLocked = true;
}

function createTimerOverlay(){
    // remove existing
    if(timerOverlay) timerOverlay.remove();

    timerOverlay = document.createElement('div');
    timerOverlay.className = 'timerOverlay locked';
    timerOverlay.style.right = '20px';
    timerOverlay.style.top = '80px';
    timerOverlay.innerHTML = `<span id="timerText"></span><button class="lockBtn" id="timerLockBtn">üîí</button>`;
    document.body.appendChild(timerOverlay);

    timerLocked = true;

    // events for lock toggle
    document.getElementById('timerLockBtn').addEventListener('click', ()=>{
        timerLocked = !timerLocked;
        if(timerLocked){
            timerOverlay.classList.add('locked');
            document.getElementById('timerLockBtn').textContent = 'üîí';
            // snap to fixed: convert current absolute position to fixed anchored position by setting right/top
            const rect = timerOverlay.getBoundingClientRect();
            const right = window.innerWidth - rect.right;
            timerOverlay.style.right = (right + 'px');
            timerOverlay.style.top = (rect.top + 'px');
            timerOverlay.style.position = 'fixed';
        } else {
            timerOverlay.classList.remove('locked');
            document.getElementById('timerLockBtn').textContent = 'üîì';
            // switch to absolute to allow dragging within the document
            const rect = timerOverlay.getBoundingClientRect();
            timerOverlay.style.position = 'absolute';
            timerOverlay.style.left = rect.left + 'px';
            timerOverlay.style.top = rect.top + 'px';
            timerOverlay.style.right = 'auto';
        }
    });

    // dragging only when unlocked
    timerOverlay.addEventListener('mousedown', (e)=>{
        if(timerLocked) return;
        dragState.active = true;
        dragState.startX = e.clientX;
        dragState.startY = e.clientY;
        dragState.initLeft = parseInt(timerOverlay.style.left || 0);
        dragState.initTop = parseInt(timerOverlay.style.top || 0);
        e.preventDefault();
    });
    document.addEventListener('mousemove', (e)=>{
        if(!dragState.active) return;
        const dx = e.clientX - dragState.startX;
        const dy = e.clientY - dragState.startY;
        timerOverlay.style.left = (dragState.initLeft + dx) + 'px';
        timerOverlay.style.top = (dragState.initTop + dy) + 'px';
    });
    document.addEventListener('mouseup', ()=>{ dragState.active = false; });
}

function updateTimerOverlay(){
    if(!timerOverlay) return;
    const minutes = Math.floor(timerRemaining / 60);
    const seconds = timerRemaining % 60;
    document.getElementById('timerText').textContent = `${minutes}:${String(seconds).padStart(2,'0')}`;
}

function setupAutoEnter(){
    const autoEnter = document.getElementById('autoEnter');
    document.querySelectorAll('#tableContainer input').forEach(input=>{
        input.addEventListener('focusout', ()=>{
            if(autoEnter.checked && input.value.trim() !== ''){
                checkInput({ key: 'Enter' }, input);
            }
        });
    });
}

function checkInput(e,input){
    if(e.key==="Enter"){
        let val = normalize(input.value);
        let ans = normalize(input.dataset.answer);

        if(input.dataset.triesBeforeCorrect === undefined){
            input.dataset.triesBeforeCorrect = val === ans ? 0 : 1;
        }

        if(val === ans){
            input.parentElement.classList.add("correct");
            input.parentElement.textContent = input.dataset.answer;
            return; // nic nie liczymy dalej
        }

        // je≈õli odpowied≈∫ b≈Çƒôdna:
        let tries = parseInt(input.dataset.tries)||0;
        let maxCell = parseInt(input.dataset.maxtries)||-1;
        let maxGlobal = savedConfig.maxGlobal;

        input.dataset.tries = tries+1;
        globalTries++;

        input.classList.add("wrong");
        setTimeout(()=>{
            input.classList.remove("wrong");
            if(document.getElementById("autoClear").checked){
                input.value=""; // kasuje tylko je≈õli opcja w≈ÇƒÖczona
            }
        },1500);

        if(maxCell!==-1 && tries+1>=maxCell){
            input.disabled=true;
            input.parentElement.classList.add("wrong");
        }

        if(maxGlobal !== -1 && globalTries>=maxGlobal && !maxGlobalExceeded){
            maxGlobalExceeded = true;
            alert("Pope≈Çni≈Çe≈õ za du≈ºo b≈Çƒôd√≥w globalnie! Test ko≈Ñczy siƒô.");
            showAll();
	    // --- wywo≈Çanie statystyk, je≈õli checkbox Statystyki jest w≈ÇƒÖczony ---
	    if (document.getElementById("showStatsCheckbox")?.checked) {
    	        const statsHtml = calculateStats(); // funkcja generujƒÖca tre≈õƒá statystyk
    		showStatsOverlay(statsHtml); // pokazuje nak≈Çadkƒô
	    }
        }
    }
}

// --- TRYB ODKRYJ WYBRANE ---
function enterDiscoverMode(){
    if(maxGlobalExceeded){
        alert("Nie mo≈ºesz odkrywaƒá pojedynczych kom√≥rek po przekroczeniu limitu globalnego.");
        return;
    }
    discoverMode = true;
    renewMode = false;
    refreshModeIndicators();
    updateCellClickHandlers();

    if(!document.getElementById("discoverDoneBtn")){
        let btn = document.createElement("button");
        btn.textContent = "Gotowe";
        btn.className = "btn btn-main";
        btn.id = "discoverDoneBtn";
        btn.onclick = ()=> {
            document.querySelectorAll("#tableContainer td.toDiscover").forEach(td=>{
                let answer = td.dataset.answer;
                td.textContent = answer;
                td.classList.add("discovered");
                td.classList.remove("toDiscover");
            });
            discoverMode = false;
            refreshModeIndicators();
            updateCellClickHandlers();
            btn.remove();
        };
        document.getElementById("quizControls").appendChild(btn);
    }
}

// --- TRYB ODN√ìW WYBRANE ---
function enterRenewMode(){
    renewMode = !renewMode;
    discoverMode = false;
    refreshModeIndicators();
    updateCellClickHandlers();
    alert("Tryb odn√≥w " + (renewMode ? "w≈ÇƒÖczony" : "wy≈ÇƒÖczony"));
}

// --- AKTUALIZACJA KLIK√ìW NA KOM√ìRKACH ---
function updateCellClickHandlers(){
    document.querySelectorAll("#tableContainer td").forEach(td=>{
        td.onclick = null;

        if(manualSelectMode){
            td.onclick = ()=> td.classList.toggle("fixed");
            return;
        }

        if(mode==="info"){
            td.onclick = ()=> td.classList.toggle("info");
            return;
        }

        if(discoverMode){
            let inp = td.querySelector("input");
            if(inp && !td.classList.contains("wrong")){
                td.onclick = ()=> td.classList.toggle("toDiscover");
            }
        }

        if(renewMode){
            td.onclick = ()=>{
                if(td.classList.contains("correct") || td.classList.contains("wrong") || td.classList.contains("discovered") || td.querySelector("input")){
                    let answer = td.dataset.answer;
                    td.classList.remove("correct","wrong","discovered","toDiscover");
                    td.innerHTML = `<input data-answer="${answer}" data-tries="0" data-maxtries="${savedConfig.maxCell||-1}" onkeydown="checkInput(event,this)">`;
                    setupAutoEnter();
                }
            };
        }
    });
}

function showAll(){
    document.querySelectorAll("td input").forEach(inp=>{
        let td=inp.parentElement;
        td.textContent=inp.dataset.answer;
        let val=normalize(inp.value);
        let ans=normalize(inp.dataset.answer);
        if(val===ans && val!==""){ td.classList.add("correct"); }
        else{ td.classList.add("wrong"); }
    });
}

function backToMenu(){
    refreshModeIndicators();
    stopTimer();

    const shuffle = document.getElementById("shuffleRows").checked;

    // Zapis aktualnego stanu info/fixed przed przywr√≥ceniem
    let tds = document.querySelectorAll("#tableContainer td");
    savedConfig.cellStates = Array.from(tds).map(td=>{
    	let cls = "";
    	if(td.classList.contains("info")) cls = "info";
    	else if(savedConfig.mode === "manual" && td.classList.contains("fixed")) cls = "fixed";

    	return {
            value: td.dataset.answer || td.textContent,
            className: cls
    	};
    });


    // Przywr√≥cenie tableData do orygina≈Çu
    tableData = JSON.parse(JSON.stringify(savedConfig.tableState));
    renderTable(true); // od razu buduje TD

    let newTds = document.querySelectorAll("#tableContainer td");

    if(!shuffle){
    	// Przywracanie po indeksach (shuffle OFF)
    	newTds.forEach((td,i)=>{
            const state = savedConfig.cellStates[i];
            if(!state) return;
            if (state.className === "info") {
                td.classList.add("info");
            }
            if (savedConfig.mode === "manual" && state.className === "fixed") {
                td.classList.add("fixed");
            }
    	});
} else {
    // Przywracanie po warto≈õci (shuffle ON)
    newTds.forEach(td=>{
        const answer = td.dataset.answer;
        const state = savedConfig.cellStates.find(s => 
            s.value && normalize(s.value) === normalize(answer)
        );
        if(state){
            if (state.className === "info") {
                td.classList.add("info");
            }
            if (savedConfig.mode === "manual" && state.className === "fixed") {
                td.classList.add("fixed");
            }
        }
    });
}

    // Przywr√≥cenie manualSelectMode tylko je≈õli tryb to "manual"
    if (savedConfig.mode === "manual") {
    	manualSelectMode = savedConfig.manualSelectMode || false;
    } else {
    	manualSelectMode = false;
    }

    // Aktualizacja klik√≥w
    updateCellClickHandlers();

    // Przywr√≥cenie extraText
    document.getElementById("extraText").value = savedConfig.extraText || "";
    document.getElementById("extraText").style.display = "block";
    document.getElementById("extraTextDisplay").style.display = "none";

    // Widoki paneli
    document.getElementById("controls").style.display="block";
    document.getElementById("quizControls").style.display="none";

    // Przywr√≥cenie ustawie≈Ñ quizu
    mode = savedConfig.mode;
    document.getElementById("fixedCount").value = savedConfig.fixedCount;
    document.getElementById("maxTries").value = savedConfig.maxGlobal;
    document.getElementById("cellTries").value = savedConfig.maxCell;
    discoverMode = false;
    renewMode = false;

    // --- wywo≈Çanie statystyk, je≈õli checkbox Statystyki jest w≈ÇƒÖczony ---
    if (document.getElementById("showStatsCheckbox")?.checked) {
        const statsHtml = calculateStats(); // funkcja generujƒÖca tre≈õƒá statystyk
        showStatsOverlay(statsHtml); // pokazuje nak≈Çadkƒô
    }
}

function clearAll(){
    document.getElementById("inputArea").value="";
    document.getElementById("tableContainer").innerHTML="";
    document.getElementById("controls").style.display="none";
    document.getElementById("quizControls").style.display="none";
    document.getElementById("extraText").value = "";
    document.getElementById("extraText").style.display = "block";
    document.getElementById("extraTextDisplay").style.display = "none";
    
    // reset zmiennych
    tableData = [];
    mode = null;
    quizMode = null;
    markMode = null;
    savedConfig = {};
    globalTries = 0;
    maxGlobalExceeded = false;
    manualSelectMode = false;
    discoverMode = false;
    renewMode = false;
    hintModeArmed = false;

    // reset input file (≈ºeby nie pokazywa≈Ço starego pliku)
    const importFile = document.getElementById("importFile");
    if(importFile) importFile.value = "";

    refreshModeIndicators();
    stopTimer();
}

// --- FUNKCJE IMPORT / EKSPORT ---
// Eksportujemy teraz obiekt { table: tableData, extraText: ... }
function exportTable(){
    const tds = document.querySelectorAll("#tableContainer td");
    const exportData = Array.from(tds).map(td => ({
        r: td.dataset.r,
        c: td.dataset.c,
        value: td.dataset.answer,
        className: td.className,
        innerHTML: td.innerHTML
    }));
    const payload = {
        table: exportData,
        extraText: document.getElementById("extraText").value || ""
    };
    const blob = new Blob([JSON.stringify(payload)], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "tabela.json";
    a.click();
    URL.revokeObjectURL(url);
}

function importTable(file){
    const reader = new FileReader();
    reader.onload = function(e){
        const data = JSON.parse(e.target.result);
        let cellsData = data.table || data; // je≈õli starszy format
        tableData = [];
        const rows = {};
        cellsData.forEach(cell=>{
            if(!rows[cell.r]) rows[cell.r]=[];
            rows[cell.r][cell.c] = cell.value;
        });
        tableData = Object.values(rows);
        renderTable(true);
        cellsData.forEach(cell=>{
            const td = document.querySelector(`td[data-r="${cell.r}"][data-c="${cell.c}"]`);
            if(td){ td.className = cell.className; td.innerHTML = cell.innerHTML; }
        });
        document.getElementById("extraText").value = data.extraText || ""; // tu dodane
        updateCellClickHandlers();
        document.getElementById("controls").style.display = "block";
        setupAutoEnter();
    }
    reader.readAsText(file);
}

function createTable(){
    let rows = prompt("Podaj liczbƒô wierszy:");
    let cols = prompt("Podaj liczbƒô kolumn:");
    if(!rows || !cols) return;

    let html="<table>";
    for(let r=0;r<rows;r++){
        html+="<tr>";
        for(let c=0;c<cols;c++){
            html+=`<td><input id="cell_${r}_${c}" style="width:95%"></td>`;
        }
        html+="</tr>";
    }
    html+="</table>";
    html+=`
        <button class="btn btn-main" onclick="saveEditedTable()">Zapisz tabelkƒô</button>
        <button class="btn btn-secondary" onclick="copyTableCode()">Kopiuj kod tabelki</button>
        <button class="btn btn-danger" onclick="closeEditor()">Zamknij</button>
    `;
    document.getElementById("tableContainer").innerHTML=html;
    document.getElementById("controls").style.display="none";
    document.getElementById("extraText").style.display = "block";
    document.getElementById("extraTextDisplay").style.display = "none";
}

function editTable(){
    if(tableData.length===0){
        alert("Najpierw wczytaj tabelƒô.");
        return;
    }
    let html="<table>";
    tableData.forEach((row,r)=>{
        html+="<tr>";
        row.forEach((cell,c)=>{
            html+=`<td><input id="cell_${r}_${c}" style="width:95%" value="${cell}"></td>`;
        });
        html+="</tr>";
    });
    html+="</table>";
    html+=`
        <button class="btn btn-main" onclick="saveEditedTable()">Zapisz tabelkƒô</button>
        <button class="btn btn-secondary" onclick="copyTableCode()">Kopiuj kod tabelki</button>
        <button class="btn btn-danger" onclick="closeEditor()">Zamknij</button>
    `;
    document.getElementById("tableContainer").innerHTML=html;
    document.getElementById("controls").style.display="none";
    document.getElementById("extraText").style.display = "block";
    document.getElementById("extraTextDisplay").style.display = "none";
}

function saveEditedTable(){
    let newData=[];
    const rows=document.querySelectorAll("#tableContainer tr");
    rows.forEach((tr,r)=>{
        let rowData=[];
        tr.querySelectorAll("input").forEach((inp,c)=>{
            rowData.push(inp.value);
        });
        newData.push(rowData);
    });
    tableData=newData;
    renderTable(true);
    // czarne dla pustych (w menu te≈º mogƒÖ byƒá czarne)
    document.querySelectorAll("#tableContainer td").forEach(td=>{
        if(!td.dataset.answer || td.dataset.answer.trim()===""){
            td.style.background="black";
            td.style.color="white";
            td.onclick=null;
        }
    });
    document.getElementById("controls").style.display="block";
    // extraText remains editable in menu
    document.getElementById("extraText").style.display = "block";
    document.getElementById("extraTextDisplay").style.display = "none";
}

function copyTableCode(){
    let code = tableData.map(row=>row.join("\t")).join("\n");
    navigator.clipboard.writeText(code).then(()=>{
        alert("Skopiowano tabelkƒô do schowka!");
    });
}

function closeEditor(){
    document.getElementById("tableContainer").innerHTML="";
    renderTable(true);
    document.getElementById("controls").style.display="block";
    document.getElementById("extraText").style.display = "block";
    document.getElementById("extraTextDisplay").style.display = "none";
}

function prepareQuizData() {
    let quizData = JSON.parse(JSON.stringify(tableData));

    // infoRows zawsze na g√≥rze
    let infoRows = quizData.filter(r => r.hasInfo);
    let normalRows = quizData.filter(r => !r.hasInfo);

    // zachowanie oryginalnej kolejno≈õci infoRows
    infoRows.sort((a,b) => a.originalIndex - b.originalIndex);

    // je≈õli shuffle w≈ÇƒÖczone, tasujemy normalRows
    if(document.getElementById("shuffleRows").checked && mode !== "manual") {
        normalRows.sort(() => 0.5 - Math.random());
    }

    return infoRows.concat(normalRows);
}

function maybeShowStats() {
    const showStats = document.getElementById("showStatsCheckbox").checked;
    if(!showStats) return;

    const statsHtml = calculateStats();
    showStatsOverlay(statsHtml);
}

function showStats(statsHtml){
    // je≈õli nak≈Çadka ju≈º istnieje, usu≈Ñ
    const existing = document.getElementById("statsOverlay");
    if(existing) existing.remove();

    const overlay = document.createElement("div");
    overlay.id = "statsOverlay";
    overlay.style.position = "fixed";
    overlay.style.top = "0";
    overlay.style.left = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.background = "rgba(0,0,0,0.85)";
    overlay.style.color = "white";
    overlay.style.zIndex = "99999";
    overlay.style.overflowY = "auto";
    overlay.style.padding = "20px";
    overlay.style.boxSizing = "border-box";
    overlay.innerHTML = `
        <h2>Statystyki Quizu</h2>
        <div>${statsHtml}</div>
        <button style="
            display:block;
            margin:20px auto 0;
            padding:10px 20px;
            font-size:16px;
            cursor:pointer;
            border:none;
            border-radius:5px;
            background:#007bff;
            color:white;
        " onclick="hideStats()">Kontynuuj</button>
    `;
    document.body.appendChild(overlay);
}

function hideStats(){
    const overlay = document.getElementById("statsOverlay");
    if(overlay) overlay.remove();
}

function calculateStats(){
    if(!tableData || tableData.length===0) return "Brak danych do statystyk.";

    let totalCells = 0;
    let correctCells = 0;
    let firstTryCorrect = 0;
    let globalErrors = 0;
    let maxCorrectStreak = 0;
    let maxWrongStreak = 0;
    let currentCorrectStreak = 0;
    let currentWrongStreak = 0;
    let usedDiscover = 0;

    let cellErrorMap = {}; // klucz: "r-c", warto≈õƒá: liczba b≈Çƒôd√≥w

    document.querySelectorAll("#tableContainer td").forEach(td=>{
        let answer = td.dataset.answer || td.textContent;
        if(!answer) return;

        totalCells++;

        // sprawdzamy, czy u≈ºytkownik poda≈Ç warto≈õƒá
        let userVal = td.dataset.uservalue || normalize(td.textContent);
        let correct = (normalize(answer) === userVal);

        // poprawne
        if(correct) correctCells++;

        // pierwsza pr√≥ba
        let tries = parseInt(td.dataset.tries || "0");
        if(correct && tries === 0) firstTryCorrect++;

        // b≈Çƒôdy globalne
        globalErrors += tries;
        if(tries>0){
            cellErrorMap[`R${td.dataset.r}-C${td.dataset.c}`] = tries;
        }

        // passy
        if(correct){
            currentCorrectStreak++;
            if(currentCorrectStreak>maxCorrectStreak) maxCorrectStreak=currentCorrectStreak;
            currentWrongStreak=0;
        } else {
            currentWrongStreak++;
            if(currentWrongStreak>maxWrongStreak) maxWrongStreak=currentWrongStreak;
            currentCorrectStreak=0;
        }

        // odkrycia
        if(td.dataset.discovered === "1" || td.classList.contains("discovered")) usedDiscover++;
    });

    // Top kom√≥rki z b≈Çƒôdami
    let topCells = Object.entries(cellErrorMap)
        .sort((a,b)=>b[1]-a[1])
        .slice(0,3)
        .map((e,i)=>`${i+1}. ${e[0]} - ${e[1]} b≈ÇƒÖd(√≥w)`);

    // procenty
    let percentGuessed = totalCells ? Math.round(correctCells/totalCells*100) : 0;
    let percentFirstTry = totalCells ? Math.round(firstTryCorrect/totalCells*100) : 0;

    // czas ‚Äì je≈õli masz zmiennƒÖ timerRemaining lub licznik startowy mo≈ºesz tu dodaƒá np. czas trwania quizu
    let timeUsed = "Niezaimplementowane"; // placeholder

    let statsHtml = `
        <p>Poprawnych odpowiedzi: ${correctCells}/${totalCells} (${percentGuessed}%)</p>
        <p>Poprawnych odpowiedzi za pierwszym razem: ${percentFirstTry}%</p>
        <p>Najwiƒôksza passa poprawnych odpowiedzi: ${maxCorrectStreak}</p>
        <p>Najwiƒôksza passa b≈Çƒôdnych odpowiedzi: ${maxWrongStreak}</p>
        <p>B≈Çƒôdy globalne: ${globalErrors}</p>
        <p>Ilo≈õƒá u≈ºyƒá odkryj wybranych: ${usedDiscover}</p>
        <p>Kom√≥rki z najwiƒôkszƒÖ ilo≈õciƒÖ b≈Çƒôd√≥w:<br>${topCells.length ? topCells.join("<br>") : "Brak b≈Çƒôd√≥w"}</p>
        <p>Czas trwania quizu: ${timeUsed}</p>
    `;
    return statsHtml;
}

function showStatsOverlay(html){
    let overlay = document.createElement("div");
    overlay.id = "statsOverlay";
    overlay.style.position = "fixed";
    overlay.style.top = "0";
    overlay.style.left = "0";
    overlay.style.width = "100%";
    overlay.style.height = "100%";
    overlay.style.background = "rgba(0,0,0,0.8)";
    overlay.style.color = "white";
    overlay.style.padding = "20px";
    overlay.style.overflowY = "auto";
    overlay.style.zIndex = "10000";
    overlay.innerHTML = `
        <div style="max-width:600px; margin:50px auto; background:#222; padding:20px; border-radius:10px;">
            ${html}
            <button style="display:block; margin:20px auto; padding:10px 20px;" onclick="document.getElementById('statsOverlay').remove()">Kontynuuj</button>
        </div>
    `;
    document.body.appendChild(overlay);
}

// ---- PATCH v6.1: stats + editor row/col ops + hints + comma answers ----
function armHintMode(){
    hintModeArmed = true;
    discoverMode = false;
    renewMode = false;
    updateCellClickHandlers();
    alert("Tryb podpowiedzi aktywny. Kliknij jedna komorke z inputem.");
}

startQuiz = function(){
    quizStartTime = Date.now();
    if(!tableData.length){ alert("Najpierw wczytaj lub stworz tabele."); return; }
    if(!mode){ alert("Wybierz tryb!"); return; }

    savedConfig = {
        mode: mode,
        fixedCount: parseInt(document.getElementById("fixedCount").value)||2,
        maxGlobal: parseInt(document.getElementById("maxTries").value)||-1,
        maxCell: parseInt(document.getElementById("cellTries").value)||-1,
        tableState: JSON.parse(JSON.stringify(tableData)),
        extraText: document.getElementById("extraText").value || "",
        cellStates: getMarkMap(),
        manualSelectMode: manualSelectMode
    };

    globalTries = 0;
    maxGlobalExceeded = false;
    discoverMode = false;
    renewMode = false;
    hintModeArmed = false;
    manualSelectMode = false;

    let quizData = JSON.parse(JSON.stringify(tableData));
    if(document.getElementById("shuffleRows").checked){
        quizData.sort(()=>0.5 - Math.random());
    }

    let html = "<table>";
    quizData.forEach((row,r)=>{
        html += "<tr>";
        const indices = row.map((_,i)=>i);
        let visible = [];
        if(mode==="random"){
            const candidate = indices.filter(i => (String(row[i] ?? "").trim() !== ""));
            const cnt = Math.max(1, Math.min(candidate.length, Math.floor(Math.random()*3)+1));
            visible = candidate.slice().sort(()=>0.5-Math.random()).slice(0,cnt);
        } else if(mode==="fixed"){
            const candidate = indices.filter(i => {
                const value = String(row[i] ?? "").trim();
                const st = savedConfig.cellStates[`${r}-${i}`] || {};
                return value !== "" && !st.excludeFixed;
            });
            const cnt = Math.max(0, Math.min(candidate.length, savedConfig.fixedCount));
            visible = candidate.slice().sort(()=>0.5-Math.random()).slice(0,cnt);
        }

        row.forEach((cell,c)=>{
            const state = savedConfig.cellStates[`${r}-${c}`] || {info:false,fixed:false};
            let tdClass="", content="", quizInput="0";
            if(state.info){ tdClass="info"; content = cell; }
            else if((mode==="manual" && state.fixed) || visible.includes(c)){ tdClass="fixed"; content = cell; }
            else{
                quizInput = "1";
                const options = parseAnswerOptions(cell).join("|");
                content = `<input data-answer="${cell}" data-options="${options}" data-tries="0" data-maxtries="${savedConfig.maxCell}" onkeydown="checkInput(event,this)">`;
            }
            html += `<td class="${tdClass}" data-r="${r}" data-c="${c}" data-answer="${cell}" data-tries="0" data-correct="${quizInput==="1"?"0":"1"}" data-firsttry="${quizInput==="1"?"0":"1"}" data-quizinput="${quizInput}">${content}</td>`;
        });
        html += "</tr>";
    });
    html += "</table>";
    document.getElementById("tableContainer").innerHTML = html;

    document.querySelectorAll("#tableContainer td").forEach(td => {
        if(!td.dataset.answer || td.dataset.answer.trim() === ""){
            td.style.background = "black";
            td.style.color = "white";
            td.innerHTML = "";
            td.onclick = null;
        }
    });

    document.getElementById("extraTextDisplay").textContent = savedConfig.extraText;
    document.getElementById("extraTextDisplay").style.display = savedConfig.extraText ? "block" : "none";
    document.getElementById("extraText").style.display = "none";
    document.getElementById("quizControls").style.display = "block";
    document.getElementById("controls").style.display = "none";
    updateCellClickHandlers();
    setupAutoEnter();

    const timeLimit = parseInt(document.getElementById("timeLimit").value);
    if(!isNaN(timeLimit) && timeLimit > 0) startTimer(timeLimit);
};

checkInput = function(e,input){
    if(e.key!=="Enter") return;
    const td = input.parentElement;
    const val = normalize(input.value);
    const options = (input.dataset.options || "").split("|").filter(Boolean);
    const isCorrect = options.includes(val);

    if(isCorrect){
        const tries = parseInt(td.dataset.tries || "0");
        td.dataset.correct = "1";
        td.dataset.firsttry = tries===0 ? "1" : "0";
        td.classList.add("correct");
        td.textContent = input.dataset.answer; // pokaz pe≈ÇnƒÖ warto≈õƒá, np. "≈ºyƒá, mieszkaƒá"
        return;
    }

    let tries = parseInt(input.dataset.tries)||0;
    let maxCell = parseInt(input.dataset.maxtries)||-1;
    let maxGlobal = savedConfig.maxGlobal;
    input.dataset.tries = tries+1;
    td.dataset.tries = (parseInt(td.dataset.tries||"0")+1);
    td.dataset.correct = "0";
    td.dataset.firsttry = "0";
    globalTries++;

    input.classList.add("wrong");
    setTimeout(()=>{
        input.classList.remove("wrong");
        if(document.getElementById("autoClear").checked) input.value="";
    },1200);

    if(maxCell!==-1 && tries+1>=maxCell){
        input.disabled=true;
        td.classList.add("wrong");
    }

    if(maxGlobal !== -1 && globalTries>=maxGlobal && !maxGlobalExceeded){
        maxGlobalExceeded = true;
        alert("Przekroczono globalny limit bledow. Test konczy sie.");
        showAll();
        if(document.getElementById("showStatsCheckbox")?.checked){
            showStatsOverlay(calculateStats());
        }
    }
};

showAll = function(){
    document.querySelectorAll("#tableContainer td input").forEach(inp=>{
        const td = inp.parentElement;
        const val = normalize(inp.value);
        const options = (inp.dataset.options || "").split("|").filter(Boolean);
        const ok = options.includes(val);
        td.dataset.correct = ok ? "1" : "0";
        td.dataset.firsttry = ok && parseInt(td.dataset.tries||"0")===0 ? "1" : "0";
        td.textContent = inp.dataset.answer;
        if(ok) td.classList.add("correct");
        else td.classList.add("wrong");
    });
};

updateCellClickHandlers = function(){
    document.querySelectorAll("#tableContainer td").forEach(td=>{
        td.onclick = null;

        if(manualSelectMode){
            td.onclick = ()=> td.classList.toggle("fixed");
            return;
        }
        if(mode==="info" && document.getElementById("controls").style.display!=="none"){
            td.onclick = ()=> td.classList.toggle("info");
            return;
        }
        if(mode==="excludeFixed" && document.getElementById("controls").style.display!=="none"){
            td.onclick = ()=> td.classList.toggle("excludeFixed");
            return;
        }
        if(hintModeArmed && td.querySelector("input")){
            td.onclick = ()=>{
                const input = td.querySelector("input");
                const answer = input.dataset.answer || "";
                const kind = prompt("1 = ilosc znakow + wyrazow, 2 = laczony (kwadraciki)", "1");
                if(kind==="2"){
                    const base = (answer.split(",")[0] || answer).trim();
                    td.querySelectorAll(".hintCombined,.hintMeta").forEach(el=>el.remove());
                    const wrap = document.createElement("div");
                    wrap.className = "hintCombined";
                    for(let i=0;i<base.length;i++){
                        const ch = base[i];
                        if(ch===" "){
                            const gap = document.createElement("span");
                            gap.className = "hintGap";
                            wrap.appendChild(gap);
                        } else {
                            const sq = document.createElement("span");
                            sq.className = "hintSquare";
                            sq.onclick = ()=>{ sq.textContent = ch; };
                            wrap.appendChild(sq);
                        }
                    }
                    td.appendChild(wrap);
                } else {
                    const clean = answer.trim();
                    const words = clean ? clean.split(/\s+/).filter(Boolean).length : 0;
                    const chars = clean.length;
                    td.querySelectorAll(".hintCombined,.hintMeta").forEach(el=>el.remove());
                    const info = document.createElement("div");
                    info.className = "hintMeta";
                    info.textContent = `Znaki: ${chars}, wyrazy: ${words}`;
                    td.appendChild(info);
                }
                hintModeArmed = false;
                updateCellClickHandlers();
            };
            return;
        }

        if(discoverMode){
            const inp = td.querySelector("input");
            if(inp && !td.classList.contains("wrong")){
                td.onclick = ()=> td.classList.toggle("toDiscover");
            }
        }

        if(renewMode){
            td.onclick = ()=>{
                if(td.classList.contains("correct") || td.classList.contains("wrong") || td.classList.contains("discovered") || td.querySelector("input")){
                    const answer = td.dataset.answer;
                    const options = parseAnswerOptions(answer).join("|");
                    td.classList.remove("correct","wrong","discovered","toDiscover");
                    td.dataset.tries = "0";
                    td.dataset.correct = "0";
                    td.dataset.firsttry = "0";
                    td.dataset.discovered = "0";
                    td.dataset.quizinput = "1";
                    td.innerHTML = `<input data-answer="${answer}" data-options="${options}" data-tries="0" data-maxtries="${savedConfig.maxCell||-1}" onkeydown="checkInput(event,this)">`;
                    setupAutoEnter();
                }
            };
        }
    });
};

backToMenu = function(){
    stopTimer();
    tableData = JSON.parse(JSON.stringify(savedConfig.tableState || []));
    renderTable(true);

    const marks = savedConfig.cellStates || {};
    document.querySelectorAll("#tableContainer td").forEach(td=>{
        const s = marks[`${td.dataset.r}-${td.dataset.c}`];
        if(!s) return;
        if(s.info) td.classList.add("info");
        if(savedConfig.mode==="manual" && s.fixed) td.classList.add("fixed");
        if(s.excludeFixed) td.classList.add("excludeFixed");
    });

    manualSelectMode = savedConfig.manualSelectMode || false;
    mode = savedConfig.mode || mode;
    quizMode = mode;
    markMode = null;
    discoverMode = false;
    renewMode = false;
    hintModeArmed = false;
    refreshModeIndicators();

    document.getElementById("extraText").value = savedConfig.extraText || "";
    document.getElementById("extraText").style.display = "block";
    document.getElementById("extraTextDisplay").style.display = "none";
    document.getElementById("controls").style.display="block";
    document.getElementById("quizControls").style.display="none";

    if(document.getElementById("showStatsCheckbox")?.checked){
        showStatsOverlay(calculateStats());
    }
};

function openEditorWithData(data){
    editorBuffer = JSON.parse(JSON.stringify(data));
    editorMode = "select";
    editorSelected = null;
    renderEditorView();
    document.getElementById("controls").style.display="none";
}

function renderEditorView(){
    let html = `<div class="editorModeLabel">Tryb edycji: ${editorMode || "select"}</div>
    <button class="btn btn-secondary ${editorMode==='add-col-left'?'active':''}" onclick="setEditorMode('add-col-left')">+ Kolumna lewo</button>
    <button class="btn btn-secondary ${editorMode==='add-col-right'?'active':''}" onclick="setEditorMode('add-col-right')">+ Kolumna prawo</button>
    <button class="btn btn-secondary ${editorMode==='add-row-up'?'active':''}" onclick="setEditorMode('add-row-up')">+ Wiersz gora</button>
    <button class="btn btn-secondary ${editorMode==='add-row-down'?'active':''}" onclick="setEditorMode('add-row-down')">+ Wiersz dol</button>
    <button class="btn btn-danger ${editorMode==='delete-col'?'active':''}" onclick="setEditorMode('delete-col')">Usun kolumne</button>
    <button class="btn btn-danger ${editorMode==='delete-row'?'active':''}" onclick="setEditorMode('delete-row')">Usun wiersz</button>
    <button class="btn btn-secondary ${editorMode==='select'?'active':''}" onclick="setEditorMode('select')">Wylacz tryb</button>`;
    html += "<table>";
    editorBuffer.forEach((row,r)=>{
        html += "<tr>";
        row.forEach((cell,c)=>{
            const selected = editorSelected && editorSelected.r===r && editorSelected.c===c ? "editorSelected" : "";
            html += `<td class="${selected}" data-r="${r}" data-c="${c}" onclick="editorCellClick(this)"><input id="cell_${r}_${c}" style="width:95%" value="${cell}"></td>`;
        });
        html += "</tr>";
    });
    html += "</table>";
    html += `<button class="btn btn-main" onclick="saveEditedTable()">Zapisz tabelke</button>
             <button class="btn btn-secondary" onclick="copyTableCode()">Kopiuj kod tabelki</button>
             <button class="btn btn-danger" onclick="closeEditor()">Zamknij</button>`;
    document.getElementById("tableContainer").innerHTML = html;
}

function syncEditorBuffer(){
    const rows = document.querySelectorAll("#tableContainer tr");
    const out = [];
    rows.forEach(tr=>{
        const row = [];
        tr.querySelectorAll("input").forEach(inp=>row.push(inp.value));
        if(row.length) out.push(row);
    });
    if(out.length) editorBuffer = out;
}

function setEditorMode(m){ editorMode = m; renderEditorView(); }

function editorCellClick(td){
    syncEditorBuffer();
    const r = parseInt(td.dataset.r), c = parseInt(td.dataset.c);
    editorSelected = {r,c};
    const cols = editorBuffer[0]?.length || 1;

    if(editorMode==="add-col-left" || editorMode==="add-col-right"){
        const idx = editorMode==="add-col-left" ? c : c+1;
        editorBuffer = editorBuffer.map(row=>{ const n=row.slice(); n.splice(idx,0,""); return n; });
    } else if(editorMode==="add-row-up" || editorMode==="add-row-down"){
        const idx = editorMode==="add-row-up" ? r : r+1;
        editorBuffer.splice(idx,0,Array(cols).fill(""));
    } else if(editorMode==="delete-col"){
        if(cols<=1){ alert("Musi zostac min. 1 kolumna."); return; }
        editorBuffer = editorBuffer.map(row=>{ const n=row.slice(); n.splice(c,1); return n; });
    } else if(editorMode==="delete-row"){
        if(editorBuffer.length<=1){ alert("Musi zostac min. 1 wiersz."); return; }
        editorBuffer.splice(r,1);
    }

    renderEditorView();
}

createTable = function(){
    let rows = parseInt(prompt("Podaj liczbe wierszy:"),10);
    let cols = parseInt(prompt("Podaj liczbe kolumn:"),10);
    if(!rows || !cols) return;
    openEditorWithData(Array.from({length:rows},()=>Array(cols).fill("")));
};

editTable = function(){
    if(tableData.length===0){ alert("Najpierw wczytaj tabele."); return; }
    openEditorWithData(tableData);
};

saveEditedTable = function(){
    syncEditorBuffer();
    tableData = JSON.parse(JSON.stringify(editorBuffer));
    editorBuffer = [];
    renderTable(true);
    document.getElementById("controls").style.display="block";
};

copyTableCode = function(){
    const src = editorBuffer.length ? editorBuffer : tableData;
    navigator.clipboard.writeText(src.map(row=>row.join("\t")).join("\n")).then(()=>alert("Skopiowano tabelke do schowka!"));
};

closeEditor = function(){
    editorBuffer = [];
    renderTable(true);
    document.getElementById("controls").style.display="block";
};

calculateStats = function(){
    const quizCells = Array.from(document.querySelectorAll("#tableContainer td[data-quizinput='1']"));
    if(!quizCells.length) return "<p>Brak komorek quizowych do podsumowania.</p>";

    let total = quizCells.length, correct = 0, firstTry = 0, errors = 0, usedDiscover = 0;
    let maxGood=0,maxBad=0,curGood=0,curBad=0;
    const errMap = [];

    quizCells.forEach(td=>{
        const ok = td.dataset.correct==="1" || td.classList.contains("correct");
        const t = parseInt(td.dataset.tries||"0");
        if(ok){ correct++; if((td.dataset.firsttry||"0")==="1") firstTry++; curGood++; curBad=0; if(curGood>maxGood) maxGood=curGood; }
        else{ curBad++; curGood=0; if(curBad>maxBad) maxBad=curBad; }
        errors += t;
        if(t>0) errMap.push({k:`R${(parseInt(td.dataset.r||0)+1)}-C${(parseInt(td.dataset.c||0)+1)}`,v:t});
        if(td.dataset.discovered==="1" || td.classList.contains("discovered")) usedDiscover++;
    });

    const top = errMap.sort((a,b)=>b.v-a.v).slice(0,3).map((x,i)=>`${i+1}. ${x.k} - ${x.v} bledow`);
    const p1 = Math.round((correct/total)*100);
    const p2 = Math.round((firstTry/total)*100);
    const sec = Math.max(0,Math.floor((Date.now()-quizStartTime)/1000));
    const tm = `${Math.floor(sec/60)}:${String(sec%60).padStart(2,"0")}`;

    return `<p>Poprawnych odpowiedzi: ${correct}/${total} (${p1}%)</p>
            <p>Poprawnych za pierwszym razem: ${firstTry}/${total} (${p2}%)</p>
            <p>Najwieksza passa poprawnych odpowiedzi: ${maxGood}</p>
            <p>Najwieksza passa blednych odpowiedzi: ${maxBad}</p>
            <p>Bledy globalne: ${errors}</p>
            <p>Ilosc uzyc odkryj wybranych: ${usedDiscover}</p>
            <p>Komorki z najwieksza iloscia bledow:<br>${top.length?top.join("<br>"):"Brak bledow"}</p>
            <p>Czas trwania quizu: ${tm}</p>`;
};

function importTableData(data){
    let cellsData = data.table || data;
    if(Array.isArray(data.table) && Array.isArray(data.table[0])){
        tableData = data.table;
        renderTable(true);
        if(Array.isArray(data.marks)){
            data.marks.forEach(m=>{
                const td = document.querySelector(`td[data-r="${m.r}"][data-c="${m.c}"]`);
                if(!td) return;
                if(m.info) td.classList.add("info");
                if(m.fixed) td.classList.add("fixed");
                if(m.excludeFixed) td.classList.add("excludeFixed");
            });
        }
    } else {
        tableData = [];
        const rows = {};
        cellsData.forEach(cell=>{
            if(!rows[cell.r]) rows[cell.r]=[];
            rows[cell.r][cell.c] = cell.value;
        });
        tableData = Object.values(rows);
        renderTable(true);
        cellsData.forEach(cell=>{
            const td = document.querySelector(`td[data-r="${cell.r}"][data-c="${cell.c}"]`);
            if(td){
                td.className = cell.className || "";
                td.innerHTML = cell.innerHTML || td.innerHTML;
            }
        });
    }
    document.getElementById("extraText").value = data.extraText || "";
    updateCellClickHandlers();
    document.getElementById("controls").style.display = "block";
}

importTable = function(file){
    const reader = new FileReader();
    reader.onload = function(e){
        const data = JSON.parse(e.target.result);
        importTableData(data);
    };
    reader.readAsText(file);
};

function parseTableInfoText(raw){
    const out = { autor: "-", data: "-", opis: "-", visibility: "tak" };
    if(!raw) return out;
    try{
        const j = JSON.parse(raw);
        out.autor = j.autor || j.author || out.autor;
        out.data = j.dataUtworzenia || j.data || j.date || out.data;
        out.opis = j.opis || j.description || out.opis;
        out.visibility = (j.visibility || j.widocznosc || out.visibility);
        return out;
    } catch(_) {}
    raw.split(/\r?\n/).forEach(line=>{
        const m = line.match(/^\s*([^:]+)\s*:\s*(.*)\s*$/);
        if(!m) return;
        const k = m[1].toLowerCase();
        const v = m[2].trim();
        if(k.includes("autor")) out.autor = v;
        else if(k.includes("data")) out.data = v;
        else if(k.includes("opis")) out.opis = v;
        else if(k.includes("visibility") || k.includes("widoczn")) out.visibility = v;
    });
    return out;
}

const DB_BASE_PATH = "bazatabelek/";
const DB_TABLE_JSON = "tabelka.json";
const DB_INFO_JSON = "tabelkainfo.json";
let dbResolvedBasePath = DB_BASE_PATH;
let dbLastListingPreview = "";

async function openDbFilePicker(){
    await showDbOverlay();
}

function looksLikeDirectoryListing(html){
    const t = String(html || "").toLowerCase();
    if(!t) return false;
    return /index of/i.test(t) || /<a\b/i.test(t) || /tabelka\.json/i.test(t);
}

async function fetchFoldersFromManifest(basePath){
    const candidates = [`${basePath}folders.json`, `${basePath}index.json`];
    for(const url of candidates){
        try{
            const res = await fetch(url, { cache: "no-store" });
            if(!res.ok) continue;
            const data = await res.json();
            if(!Array.isArray(data)) continue;
            const names = data
                .map(x => typeof x === "string" ? x : (x.folder || x.name || x.nazwa || ""))
                .map(x => String(x).trim())
                .filter(Boolean);
            if(names.length) return names;
        } catch(_){}
    }
    return [];
}

async function fetchFoldersFromGitHubApi(){
    const host = window.location.hostname.toLowerCase();
    if(!host.endsWith(".github.io")) return [];

    const owner = host.split(".")[0];
    const segs = window.location.pathname.split("/").filter(Boolean);

    // project page: /<repo>/...
    // user/organization page: /...
    const repo = segs.length ? segs[0] : `${owner}.github.io`;
    const branchCandidates = ["main", "master"];

    for(const branch of branchCandidates){
        try{
            const apiUrl = `https://api.github.com/repos/${owner}/${repo}/contents/bazatabelek?ref=${branch}`;
            const res = await fetch(apiUrl, { cache: "no-store" });
            if(!res.ok) continue;
            const data = await res.json();
            if(!Array.isArray(data)) continue;
            const names = data
                .filter(x => x && x.type === "dir" && x.name)
                .map(x => String(x.name).trim())
                .filter(Boolean);
            if(names.length){
                return names;
            }
        } catch(_){}
    }
    return [];
}

async function discoverDbFolders(){
    const candidates = ["./bazatabelek/", "bazatabelek/", "/bazatabelek/"];
    for(const candidate of candidates){
        let txt = "";
        try{
            const res = await fetch(candidate, { cache: "no-store" });
            txt = await res.text();
            dbLastListingPreview = String(txt || "").slice(0, 1200);
        } catch(_){}

        if(looksLikeDirectoryListing(txt)){
            dbResolvedBasePath = candidate;
            const fromHtml = getDirectoryLinksFromHtml(txt);
            if(fromHtml.length){
                return { basePath: candidate, folders: fromHtml };
            }
        }

        const fromManifest = await fetchFoldersFromManifest(candidate);
        if(fromManifest.length){
            dbResolvedBasePath = candidate;
            return { basePath: candidate, folders: fromManifest };
        }
    }

    // GitHub Pages nie udostƒôpnia listingu katalog√≥w ‚Äì spr√≥buj przez API GitHub.
    const fromGhApi = await fetchFoldersFromGitHubApi();
    if(fromGhApi.length){
        dbResolvedBasePath = "./bazatabelek/";
        return { basePath: dbResolvedBasePath, folders: fromGhApi };
    }
    return null;
}

function getDirectoryLinksFromHtml(html){
    const out = new Set();
    const baseUrl = new URL(dbResolvedBasePath || DB_BASE_PATH, window.location.href);
    const basePath = baseUrl.pathname.endsWith("/") ? baseUrl.pathname : (baseUrl.pathname + "/");
    const safeDecode = (v) => { try { return decodeURIComponent(v); } catch(_) { return v; } };

    // 1) DOM links
    try{
        const doc = new DOMParser().parseFromString(html, "text/html");
        doc.querySelectorAll("a[href]").forEach(a=>{
            const href = (a.getAttribute("href") || "").trim();
            if(!href || href === "../" || href.startsWith("?") || href.startsWith("#")) return;
            let u;
            try { u = new URL(href, baseUrl.href); } catch(_) { return; }
            if(u.origin !== window.location.origin) return;
            if(!u.pathname.startsWith(basePath)) return;
            let rel = safeDecode(u.pathname.slice(basePath.length)).replace(/\/+$/,"");
            if(!rel || rel.includes("/")) return;
            if(rel.toLowerCase().endsWith(".json")) return;
            out.add(rel);
        });
    } catch(_){}

    // 2) Raw regex fallback (Apache/Nginx/custom index)
    const re = /href\s*=\s*["']([^"']+)["']/gi;
    let m;
    while((m = re.exec(html)) !== null){
        const href = (m[1] || "").trim();
        if(!href || href === "../" || href.startsWith("?") || href.startsWith("#")) continue;
        let u;
        try { u = new URL(href, baseUrl.href); } catch(_) { continue; }
        if(u.origin !== window.location.origin) continue;
        if(!u.pathname.startsWith(basePath)) continue;
        let rel = safeDecode(u.pathname.slice(basePath.length)).replace(/\/+$/,"");
        if(!rel || rel.includes("/")) continue;
        if(rel.toLowerCase().endsWith(".json")) continue;
        out.add(rel);
    }

    // 3) Fallback po samym tekscie (gdy listing jest niestandardowy)
    const txtRe = /([^\s"'<>\[\]]+?)\/(?=\s|<|$)/g;
    let t;
    while((t = txtRe.exec(html)) !== null){
        const rel = t[1].trim();
        if(!rel) continue;
        if(rel === "." || rel === "..") continue;
        if(rel.includes("/")) continue;
        if(rel.toLowerCase().endsWith(".json")) continue;
        out.add(rel);
    }

    // 4) Fallback: wyciaganie folderu ze sciezek do tabelka.json
    const p1 = /(?:^|["'\s>])(?:\.?\/)?bazatabelek\/([^\/"'?<>\n\r]+)\/tabelka\.json/gi;
    let m1;
    while((m1 = p1.exec(html)) !== null){
        const rel = safeDecode((m1[1] || "").trim());
        if(rel) out.add(rel);
    }

    // 5) Fallback: wyciaganie folderu z lokalnych sciezek "<folder>/tabelka.json"
    const p2 = /(?:^|["'\s>])([^\/"'?<>\n\r]+)\/tabelka\.json/gi;
    let m2;
    while((m2 = p2.exec(html)) !== null){
        const rel = safeDecode((m2[1] || "").trim());
        if(!rel) continue;
        if(rel === "." || rel === "..") continue;
        if(rel.toLowerCase() === "bazatabelek") continue;
        out.add(rel);
    }

    return Array.from(out);
}

function parseDateSafe(value){
    if(!value || value === "-") return 0;
    const t = Date.parse(value);
    if(!Number.isNaN(t)) return t;
    const m = String(value).match(/^(\d{1,2})[.\-/](\d{1,2})[.\-/](\d{4})$/);
    if(m){
        const dd = m[1].padStart(2,"0");
        const mm = m[2].padStart(2,"0");
        const yyyy = m[3];
        const t2 = Date.parse(`${yyyy}-${mm}-${dd}`);
        if(!Number.isNaN(t2)) return t2;
    }
    return 0;
}

async function showDbOverlay(){
    const overlayId = "dbOverlay";
    document.getElementById(overlayId)?.remove();
    const overlay = document.createElement("div");
    overlay.id = overlayId;
    overlay.className = "dbOverlay";
    overlay.innerHTML = `<div class="dbPanel">
        <div style="display:flex; gap:8px; align-items:center;">
            <h3 style="margin:0;">Baza tabelek (JSON)</h3>
            <button class="btn btn-secondary" style="margin-left:auto;" onclick="showDbOverlay()">Odswiez</button>
            <button class="btn btn-danger" onclick="document.getElementById('${overlayId}').remove()">Zamknij</button>
        </div>
        <div id="dbList" style="margin-top:10px;">Ladowanie...</div>
    </div>`;
    document.body.appendChild(overlay);

    const list = document.getElementById("dbList");
    const discovered = await discoverDbFolders();
    if(!discovered){
        list.innerHTML = `Brak folderow tabelek w bazatabelek.<br>
        Sprawdzone sciezki: <code>./bazatabelek/</code>, <code>bazatabelek/</code>, <code>/bazatabelek/</code>.<br>
        Jesli serwer blokuje listing, dodaj <code>bazatabelek/folders.json</code> z lista folderow, np.:<br>
        <pre>["Niemiecki Kartkowka Dzial I - t. 1-3"]</pre>
        <details><summary>Podglad odpowiedzi serwera (debug)</summary><pre>${(dbLastListingPreview || "").replace(/</g,"&lt;")}</pre></details>`;
        return;
    }
    dbResolvedBasePath = discovered.basePath;
    const folders = discovered.folders;

    const items = [];
    for(const folderName of folders){
        const base = `${dbResolvedBasePath}${encodeURIComponent(folderName)}/`;
        const jsonUrl = `${base}${DB_TABLE_JSON}`;
        const infoUrl = `${base}${DB_INFO_JSON}`;
        const bust = `?t=${Date.now()}`;

        let tableDataObj = null;
        try{
            const resJson = await fetch(jsonUrl + bust, { cache: "no-store" });
            if(!resJson.ok) continue;
            tableDataObj = await resJson.json();
        } catch(_){ continue; }

        let infoText = "";
        try{
            const r = await fetch(infoUrl + bust, { cache: "no-store" });
            if(r.ok) infoText = await r.text();
        } catch(_){}
        const meta = parseTableInfoText(infoText);
        if(String(meta.visibility || "tak").toLowerCase() !== "tak") continue;
        items.push({ folder: folderName, jsonUrl, tableDataObj, meta });
    }

    if(!items.length){
        list.innerHTML = "Nie znaleziono poprawnych tabelek. Oczekiwany uklad: bazatabelek/<nazwa>/tabelka.json (visibility: tak).";
        return;
    }

    items.sort((a,b)=>parseDateSafe(b.meta.data)-parseDateSafe(a.meta.data));

    list.innerHTML = items.map((x,i)=>`
        <div class="dbItem">
            <div><b>${x.folder}</b></div>
            <div>Autor: ${x.meta.autor}</div>
            <div>Data utworzenia: ${x.meta.data}</div>
            <div>Opis: ${x.meta.opis}</div>
            <div>Visibility: ${x.meta.visibility}</div>
            <button class="btn btn-main" onclick="loadDbItem(${i})">Wczytaj</button>
            <button class="btn btn-secondary" onclick="downloadDbItem(${i})">Pobierz</button>
        </div>
    `).join("");
    window.__dbItems = items;
}

async function loadDbItem(index){
    const item = window.__dbItems?.[index];
    if(!item) return;
    try{
        const data = item.tableDataObj || (await (await fetch(item.jsonUrl + `?t=${Date.now()}`, { cache: "no-store" })).json());
        importTableData(data);
        document.getElementById("dbOverlay")?.remove();
    } catch(_){
        alert("Nie udalo sie wczytac pliku z bazy.");
    }
}

function downloadDbItem(index){
    const item = window.__dbItems?.[index];
    if(!item) return;
    const a = document.createElement("a");
    a.href = item.jsonUrl;
    a.download = `${item.folder}.json`;
    a.click();
}

// ---- PATCH v6.2 ----
let ignoreWrongStreakStats = false;
let hintOverlayState = { td: null, type: "1" };

function getOriginalCellKey(td){
    const r = td.dataset.origr ?? td.dataset.r;
    const c = td.dataset.origc ?? td.dataset.c;
    return `${r}-${c}`;
}

function setActiveBtn(id, active){
    const el = document.getElementById(id);
    if(!el) return;
    el.classList.toggle("active", !!active);
}

function refreshModeIndicators(){
    setActiveBtn("modeRandomBtn", quizMode === "random");
    setActiveBtn("modeFixedBtn", quizMode === "fixed");
    setActiveBtn("modeManualBtn", quizMode === "manual");
    setActiveBtn("modeInfoBtn", markMode === "info");
    setActiveBtn("modeExcludeFixedBtn", markMode === "excludeFixed");
    setActiveBtn("manualSelectBtn", manualSelectMode);
    setActiveBtn("discoverModeBtn", discoverMode);
    setActiveBtn("renewModeBtn", renewMode);
    setActiveBtn("hintModeBtn", hintModeArmed);
}

setMode = function(m){
    if(m === "random" || m === "fixed" || m === "manual"){
        mode = m;
        quizMode = m;
    } else if(m === "info" || m === "excludeFixed"){
        markMode = m;
    }
    manualSelectMode = false;
    discoverMode = false;
    renewMode = false;
    hintModeArmed = false;
    refreshModeIndicators();
    updateCellClickHandlers();
};

toggleManualSelect = function(){
    manualSelectMode = !manualSelectMode;
    if(manualSelectMode) markMode = null;
    discoverMode = false;
    renewMode = false;
    hintModeArmed = false;
    refreshModeIndicators();
    updateCellClickHandlers();
};

createTimerOverlay = function(){
    if(timerOverlay) timerOverlay.remove();
    timerOverlay = document.createElement('div');
    timerOverlay.className = 'timerOverlay locked';
    timerOverlay.style.position = 'fixed';
    timerOverlay.style.right = '20px';
    timerOverlay.style.top = '80px';
    timerOverlay.innerHTML = `<span id="timerText"></span><button class="lockBtn" id="timerLockBtn">üîí</button>`;
    document.body.appendChild(timerOverlay);
    timerLocked = true;

    document.getElementById('timerLockBtn').addEventListener('click', ()=>{
        timerLocked = !timerLocked;
        timerOverlay.classList.toggle('locked', timerLocked);
        document.getElementById('timerLockBtn').textContent = timerLocked ? 'üîí' : 'üîì';
    });

    timerOverlay.addEventListener('mousedown', (e)=>{
        if(timerLocked) return;
        dragState.active = true;
        dragState.startX = e.clientX;
        dragState.startY = e.clientY;
        const rect = timerOverlay.getBoundingClientRect();
        dragState.initLeft = rect.left;
        dragState.initTop = rect.top;
        e.preventDefault();
    });
    document.addEventListener('mousemove', (e)=>{
        if(!dragState.active) return;
        const left = dragState.initLeft + (e.clientX - dragState.startX);
        const top = dragState.initTop + (e.clientY - dragState.startY);
        timerOverlay.style.left = left + 'px';
        timerOverlay.style.top = top + 'px';
        timerOverlay.style.right = 'auto';
        timerOverlay.style.position = 'fixed';
    });
    document.addEventListener('mouseup', ()=>{ dragState.active = false; });
};

editorCellClick = function(td){
    syncEditorBuffer();
    const r = parseInt(td.dataset.r), c = parseInt(td.dataset.c);
    editorSelected = {r,c};
    const cols = editorBuffer[0]?.length || 1;

    if(editorMode === "select"){
        return;
    } else if(editorMode==="add-col-left" || editorMode==="add-col-right"){
        const idx = editorMode==="add-col-left" ? c : c+1;
        editorBuffer = editorBuffer.map(row=>{ const n=row.slice(); n.splice(idx,0,""); return n; });
    } else if(editorMode==="add-row-up" || editorMode==="add-row-down"){
        const idx = editorMode==="add-row-up" ? r : r+1;
        editorBuffer.splice(idx,0,Array(cols).fill(""));
    } else if(editorMode==="delete-col"){
        if(cols<=1){ alert("Musi zostac min. 1 kolumna."); return; }
        editorBuffer = editorBuffer.map(row=>{ const n=row.slice(); n.splice(c,1); return n; });
    } else if(editorMode==="delete-row"){
        if(editorBuffer.length<=1){ alert("Musi zostac min. 1 wiersz."); return; }
        editorBuffer.splice(r,1);
    }
    renderEditorView();
};

function ensureHintBadge(td){
    td.classList.add("hasHintBadge");
    let btn = td.querySelector(".hintBadgeBtn");
    if(btn) return;
    btn = document.createElement("button");
    btn.className = "hintBadgeBtn";
    btn.textContent = "üí°";
    btn.onclick = (ev)=>{
        ev.stopPropagation();
        openHintOverlay(td, td.dataset.hintType || "1");
    };
    td.appendChild(btn);
}

function renderHintInCell(td, type){
    const inp = td.querySelector("input");
    if(!inp) return;
    const answer = (inp.dataset.answer || td.dataset.answer || "").trim();
    td.querySelectorAll(".hintCombined,.hintMeta").forEach(el=>el.remove());

    if(type === "2"){
        const base = (answer.split(",")[0] || answer).trim();
        const wrap = document.createElement("div");
        wrap.className = "hintCombined";
        for(let i=0;i<base.length;i++){
            const ch = base[i];
            if(ch === " "){
                const gap = document.createElement("span");
                gap.className = "hintGap";
                wrap.appendChild(gap);
            } else {
                const sq = document.createElement("span");
                sq.className = "hintSquare";
                sq.onclick = ()=>{ sq.textContent = ch; };
                wrap.appendChild(sq);
            }
        }
        td.appendChild(wrap);
    } else {
        const words = answer ? answer.split(/\s+/).filter(Boolean).length : 0;
        const chars = answer.length;
        const info = document.createElement("div");
        info.className = "hintMeta";
        info.textContent = `Znaki: ${chars}, wyrazy: ${words}`;
        td.appendChild(info);
    }
}

function applyHintTypeToCell(td, type){
    if(!td || !td.querySelector("input")) return;
    td.dataset.hintActive = "1";
    td.dataset.hintType = type || "1";
    ensureHintBadge(td);
    renderHintInCell(td, td.dataset.hintType);
}

function disableHintForCell(td){
    if(!td) return;
    td.dataset.hintActive = "0";
    td.querySelectorAll(".hintCombined,.hintMeta,.hintBadgeBtn").forEach(el=>el.remove());
    td.classList.remove("hasHintBadge");
}

function renderHintOverlay(){
    const td = hintOverlayState.td;
    if(!td) return;
    const container = document.getElementById("hintContent");
    if(!container) return;
    const active = td.dataset.hintActive === "1";
    const type = hintOverlayState.type || td.dataset.hintType || "1";
    container.innerHTML = `
        <div class="hintMeta" style="font-size:14px;">
            Status: ${active ? "wlaczona" : "wylaczona"} | Typ: ${type === "2" ? "kwadraciki" : "znaki + wyrazy"}
        </div>
        <div style="margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;">
            <button class="btn btn-secondary" onclick="setHintTypeFromOverlay('1')">Znaki + wyrazy</button>
            <button class="btn btn-secondary" onclick="setHintTypeFromOverlay('2')">Laczony (kwadraciki)</button>
            <button class="btn btn-danger" onclick="disableHintFromOverlay()">Wylacz podpowiedz</button>
        </div>`;
}

function setHintTypeFromOverlay(type){
    const td = hintOverlayState.td;
    if(!td) return;
    hintOverlayState.type = type;
    applyHintTypeToCell(td, type);
    renderHintOverlay();
}

function disableHintFromOverlay(){
    const td = hintOverlayState.td;
    if(!td) return;
    disableHintForCell(td);
    renderHintOverlay();
}

function openHintOverlay(td, forcedType){
    hintOverlayState.td = td;
    hintOverlayState.type = forcedType || td.dataset.hintType || "1";

    let overlay = document.getElementById("hintOverlay");
    if(!overlay){
        overlay = document.createElement("div");
        overlay.id = "hintOverlay";
        overlay.style.position = "fixed";
        overlay.style.inset = "0";
        overlay.style.background = "rgba(0,0,0,0.75)";
        overlay.style.zIndex = "12000";
        overlay.innerHTML = `
            <div style="max-width:700px; margin:40px auto; background:#fff; border-radius:10px; padding:16px;">
                <div style="display:flex; gap:8px; margin-bottom:8px;">
                    <button class="btn btn-secondary" onclick="setHintTypeFromOverlay('1')">Znaki + wyrazy</button>
                    <button class="btn btn-secondary" onclick="setHintTypeFromOverlay('2')">Laczony (kwadraciki)</button>
                    <button class="btn btn-danger" style="margin-left:auto;" onclick="document.getElementById('hintOverlay').remove()">Zamknij</button>
                </div>
                <div id="hintContent"></div>
            </div>`;
        document.body.appendChild(overlay);
    }
    renderHintOverlay();
}

function applyHintAnswerToQuiz(){
    const td = hintOverlayState.td;
    if(!td) return;
    const inp = td.querySelector("input");
    const source = document.getElementById("hintAnswerInput");
    if(!source) return;
    if(inp){
        inp.value = source.value;
        checkInput({key:"Enter"}, inp);
    }
}

armHintMode = function(){
    hintModeArmed = true;
    discoverMode = false;
    renewMode = false;
    manualSelectMode = false;
    refreshModeIndicators();
    updateCellClickHandlers();
    alert("Tryb podpowiedzi aktywny. Kliknij komorke z inputem.");
};

startQuiz = function(){
    quizStartTime = Date.now();
    ignoreWrongStreakStats = false;
    if(!tableData.length){ alert("Najpierw wczytaj lub stworz tabele."); return; }
    if(!mode){ alert("Wybierz tryb!"); return; }

    const markMap = getMarkMap();
    savedConfig = {
        mode: mode,
        fixedCount: parseInt(document.getElementById("fixedCount").value)||2,
        maxGlobal: parseInt(document.getElementById("maxTries").value)||-1,
        maxCell: parseInt(document.getElementById("cellTries").value)||-1,
        tableState: JSON.parse(JSON.stringify(tableData)),
        extraText: document.getElementById("extraText").value || "",
        cellStates: markMap,
        manualSelectMode: manualSelectMode
    };

    globalTries = 0;
    maxGlobalExceeded = false;
    discoverMode = false;
    renewMode = false;
    hintModeArmed = false;
    manualSelectMode = false;
    markMode = null;
    refreshModeIndicators();

    let quizRows = tableData.map((row, idx)=>({ row, origR: idx }));
    const isFullInfoRow = (row, origR) => {
        const nonEmpty = row
            .map((cell, c)=>({ cell: String(cell ?? "").trim(), c }))
            .filter(x=>x.cell !== "");
        if(!nonEmpty.length) return false;
        return nonEmpty.every(x => (markMap[`${origR}-${x.c}`] || {}).info);
    };

    const infoTopRows = [];
    const normalRows = [];
    quizRows.forEach(r=>{
        if(isFullInfoRow(r.row, r.origR)) infoTopRows.push(r);
        else normalRows.push(r);
    });

    if(document.getElementById("shuffleRows").checked){
        normalRows.sort(()=>0.5 - Math.random());
    }
    quizRows = infoTopRows.concat(normalRows);

    let html = "<table>";
    quizRows.forEach((rowObj,rView)=>{
        html += "<tr>";
        const row = rowObj.row;
        const origR = rowObj.origR;
        const indices = row.map((_,i)=>i);
        let visible = [];

        if(mode==="random"){
            const candidate = indices.filter(i => String(row[i] ?? "").trim() !== "");
            const cnt = Math.max(1, Math.min(candidate.length, Math.floor(Math.random()*3)+1));
            visible = candidate.slice().sort(()=>0.5-Math.random()).slice(0,cnt);
        } else if(mode==="fixed"){
            const candidate = indices.filter(i => {
                const value = String(row[i] ?? "").trim();
                const st = markMap[`${origR}-${i}`] || {};
                return value !== "" && !st.excludeFixed;
            });
            const cnt = Math.max(0, Math.min(candidate.length, savedConfig.fixedCount));
            visible = candidate.slice().sort(()=>0.5-Math.random()).slice(0,cnt);
        }

        row.forEach((cell,c)=>{
            const state = markMap[`${origR}-${c}`] || {info:false,fixed:false,excludeFixed:false};
            let tdClass = state.excludeFixed ? "excludeFixed" : "";
            let content = "";
            let quizInput = "0";
            if(state.info){ tdClass += (tdClass ? " " : "") + "info"; content = cell; }
            else if((mode==="manual" && state.fixed) || visible.includes(c)){ tdClass += (tdClass ? " " : "") + "fixed"; content = cell; }
            else{
                quizInput = "1";
                const options = parseAnswerOptions(cell).join("|");
                content = `<input data-answer="${cell}" data-options="${options}" data-tries="0" data-maxtries="${savedConfig.maxCell}" onkeydown="checkInput(event,this)">`;
            }
            html += `<td class="${tdClass}" data-r="${rView}" data-c="${c}" data-origr="${origR}" data-origc="${c}" data-answer="${cell}" data-tries="0" data-correct="${quizInput==="1"?"0":"1"}" data-firsttry="${quizInput==="1"?"0":"1"}" data-quizinput="${quizInput}">${content}</td>`;
        });
        html += "</tr>";
    });
    html += "</table>";
    document.getElementById("tableContainer").innerHTML = html;

    document.querySelectorAll("#tableContainer td").forEach(td=>{
        if(!td.dataset.answer || td.dataset.answer.trim()===""){
            td.style.background = "black";
            td.style.color = "white";
            td.innerHTML = "";
            td.onclick = null;
        }
    });

    document.getElementById("extraTextDisplay").textContent = savedConfig.extraText;
    document.getElementById("extraTextDisplay").style.display = savedConfig.extraText ? "block" : "none";
    document.getElementById("extraText").style.display = "none";
    document.getElementById("quizControls").style.display = "block";
    document.getElementById("controls").style.display = "none";
    updateCellClickHandlers();
    setupAutoEnter();

    const timeLimit = parseInt(document.getElementById("timeLimit").value);
    if(!isNaN(timeLimit) && timeLimit > 0) startTimer(timeLimit);
};

updateCellClickHandlers = function(){
    document.querySelectorAll("#tableContainer td").forEach(td=>{
        td.onclick = null;

        if(manualSelectMode){
            td.onclick = ()=> td.classList.toggle("fixed");
            return;
        }
        if(markMode==="info" && document.getElementById("controls").style.display!=="none"){
            td.onclick = ()=> td.classList.toggle("info");
            return;
        }
        if(markMode==="excludeFixed" && document.getElementById("controls").style.display!=="none"){
            td.onclick = ()=> td.classList.toggle("excludeFixed");
            return;
        }
        if(hintModeArmed && td.querySelector("input")){
            td.onclick = ()=>{
                hintModeArmed = false;
                refreshModeIndicators();
                openHintOverlay(td, td.dataset.hintType || "1");
                updateCellClickHandlers();
            };
            return;
        }

        if(discoverMode){
            const inp = td.querySelector("input");
            if(inp && !td.classList.contains("wrong")){
                td.onclick = ()=> td.classList.toggle("toDiscover");
                return;
            }
        }

        if(renewMode){
            td.onclick = ()=>{
                if(td.classList.contains("correct") || td.classList.contains("wrong") || td.classList.contains("discovered") || td.querySelector("input")){
                    const answer = td.dataset.answer;
                    const options = parseAnswerOptions(answer).join("|");
                    td.classList.remove("correct","wrong","discovered","toDiscover");
                    td.dataset.tries = "0";
                    td.dataset.correct = "0";
                    td.dataset.firsttry = "0";
                    td.dataset.discovered = "0";
                    td.dataset.quizinput = "1";
                    td.dataset.hintActive = "0";
                    td.classList.remove("hasHintBadge");
                    td.innerHTML = `<input data-answer="${answer}" data-options="${options}" data-tries="0" data-maxtries="${savedConfig.maxCell||-1}" onkeydown="checkInput(event,this)">`;
                    setupAutoEnter();
                }
            };
        }
    });
};

showAll = function(){
    ignoreWrongStreakStats = true;
    document.querySelectorAll("#tableContainer td input").forEach(inp=>{
        const td = inp.parentElement;
        const val = normalize(inp.value);
        const options = (inp.dataset.options || "").split("|").filter(Boolean);
        const ok = options.includes(val);
        td.dataset.correct = ok ? "1" : "0";
        td.dataset.firsttry = ok && parseInt(td.dataset.tries||"0")===0 ? "1" : "0";
        td.textContent = inp.dataset.answer;
        if(ok) td.classList.add("correct");
        else td.classList.add("wrong");
    });
};

checkInput = function(e,input){
    if(e.key!=="Enter") return;
    const td = input.parentElement;
    const val = normalize(input.value);
    const options = (input.dataset.options || "").split("|").filter(Boolean);
    const isCorrect = options.includes(val);

    if(isCorrect){
        const tries = parseInt(td.dataset.tries || "0");
        td.dataset.correct = "1";
        td.dataset.firsttry = tries===0 ? "1" : "0";
        td.classList.add("correct");
        td.textContent = input.dataset.answer;
        return;
    }

    let tries = parseInt(input.dataset.tries)||0;
    let maxCell = parseInt(input.dataset.maxtries)||-1;
    let maxGlobal = savedConfig.maxGlobal;
    input.dataset.tries = tries+1;
    td.dataset.tries = (parseInt(td.dataset.tries||"0")+1);
    td.dataset.correct = "0";
    td.dataset.firsttry = "0";
    globalTries++;

    input.classList.add("wrong");
    setTimeout(()=>{
        input.classList.remove("wrong");
        if(document.getElementById("autoClear").checked) input.value="";
    },1200);

    if(maxCell!==-1 && tries+1>=maxCell){
        input.disabled=true;
        td.classList.add("wrong");
    }
    if(maxGlobal !== -1 && globalTries>=maxGlobal && !maxGlobalExceeded){
        maxGlobalExceeded = true;
        alert("Przekroczono globalny limit bledow. Test konczy sie.");
        showAll();
        if(document.getElementById("showStatsCheckbox")?.checked) showStatsOverlay(calculateStats());
    }
};

calculateStats = function(){
    const quizCells = Array.from(document.querySelectorAll("#tableContainer td[data-quizinput='1']"));
    if(!quizCells.length) return "<p>Brak komorek quizowych do podsumowania.</p>";

    let total = quizCells.length, correct = 0, firstTry = 0, errors = 0, usedDiscover = 0;
    let maxGood=0,maxBad=0,curGood=0,curBad=0;
    const errMap = [];

    quizCells.forEach(td=>{
        const ok = td.dataset.correct==="1" || td.classList.contains("correct");
        const t = parseInt(td.dataset.tries||"0");
        if(ok){
            correct++;
            if((td.dataset.firsttry||"0")==="1") firstTry++;
            curGood++; curBad=0; if(curGood>maxGood) maxGood=curGood;
        } else if(!ignoreWrongStreakStats){
            curBad++; curGood=0; if(curBad>maxBad) maxBad=curBad;
        }
        errors += t;
        if(t>0){
            const answerText = (td.dataset.answer || "").trim() || "(pusta)";
            errMap.push({k:answerText,v:t});
        }
        if(td.dataset.discovered==="1" || td.classList.contains("discovered")) usedDiscover++;
    });

    if(ignoreWrongStreakStats) maxBad = 0;
    const top = errMap
        .sort((a,b)=>b.v-a.v)
        .slice(0,3)
        .map((x,i)=>`${i+1}. ${x.k} - ${x.v} bledow`);
    const p1 = Math.round((correct/total)*100);
    const p2 = Math.round((firstTry/total)*100);
    const sec = Math.max(0,Math.floor((Date.now()-quizStartTime)/1000));
    const tm = `${Math.floor(sec/60)}:${String(sec%60).padStart(2,"0")}`;

    return `<p>Poprawnych odpowiedzi: ${correct}/${total} (${p1}%)</p>
            <p>Poprawnych za pierwszym razem: ${firstTry}/${total} (${p2}%)</p>
            <p>Najwieksza passa poprawnych odpowiedzi: ${maxGood}</p>
            <p>Najwieksza passa blednych odpowiedzi: ${maxBad}</p>
            <p>Bledy globalne: ${errors}</p>
            <p>Ilosc uzyc odkryj wybranych: ${usedDiscover}</p>
            <p>Komorki z najwieksza iloscia bledow:<br>${top.length?top.join("<br>"):"Brak bledow"}</p>
            <p>Czas trwania quizu: ${tm}</p>`;
};

document.addEventListener("DOMContentLoaded", refreshModeIndicators);

// ---- PATCH v6.3: end test + settings + shortcuts + no-hint stats ----
let selectedQuizCell = null;
let lastQuizCell = null;
let hoveredQuizCell = null;
let backtickHeld = false;
let editorShortcutMode = null;
let quizHintShortcutMode = false;
const UI_PREFS_KEY = "tabelka_ui_prefs_v1";
let uiPrefs = { theme: "default", liquid: true };

function applyUiPrefs(){
    document.body.classList.remove("theme-black","theme-white","theme-purple","no-liquid");
    if(uiPrefs.theme === "black") document.body.classList.add("theme-black");
    else if(uiPrefs.theme === "white") document.body.classList.add("theme-white");
    else if(uiPrefs.theme === "purple") document.body.classList.add("theme-purple");
    if(!uiPrefs.liquid) document.body.classList.add("no-liquid");
}

function saveUiPrefs(){
    try { localStorage.setItem(UI_PREFS_KEY, JSON.stringify(uiPrefs)); } catch(_){}
}

function loadUiPrefs(){
    try{
        const raw = localStorage.getItem(UI_PREFS_KEY);
        if(!raw) return;
        const obj = JSON.parse(raw);
        if(obj && typeof obj === "object"){
            if(["default","black","white","purple"].includes(obj.theme)) uiPrefs.theme = obj.theme;
            if(typeof obj.liquid === "boolean") uiPrefs.liquid = obj.liquid;
        }
    } catch(_){}
}

function setTheme(theme){
    uiPrefs.theme = theme;
    applyUiPrefs();
    saveUiPrefs();
}

function setLiquidButtons(enabled){
    uiPrefs.liquid = !!enabled;
    applyUiPrefs();
    saveUiPrefs();
}

endQuiz = function(){
    showAll();
    if(document.getElementById("showStatsCheckbox")?.checked){
        showStatsOverlay(calculateStats());
    }
};

function isQuizActive(){
    return document.getElementById("quizControls")?.style.display !== "none" &&
           document.getElementById("controls")?.style.display === "none";
}

function isEditorActive(){
    return !!document.querySelector("#tableContainer .editorModeLabel");
}

function setSelectedQuizCell(td){
    if(selectedQuizCell && selectedQuizCell !== td) selectedQuizCell.classList.remove("quizCellSelected");
    selectedQuizCell = td || null;
    if(selectedQuizCell) selectedQuizCell.classList.add("quizCellSelected");
}

function clearSelectedQuizCell(){
    if(selectedQuizCell){
        selectedQuizCell.classList.remove("quizCellSelected");
        selectedQuizCell = null;
    }
}

function getSelectedQuizCell(){
    if(hoveredQuizCell && hoveredQuizCell.isConnected && hoveredQuizCell.dataset.quizinput === "1"){
        setSelectedQuizCell(hoveredQuizCell);
        return hoveredQuizCell;
    }
    if(selectedQuizCell && selectedQuizCell.isConnected && selectedQuizCell.querySelector("input")) return selectedQuizCell;
    const fallback = document.querySelector("#tableContainer td[data-quizinput='1'] input")?.parentElement || null;
    if(fallback) setSelectedQuizCell(fallback);
    return fallback;
}

function revealSingleCell(td){
    if(!td || !td.querySelector("input")) return;
    td.textContent = td.dataset.answer || "";
    td.classList.add("discovered");
    td.dataset.discovered = "1";
    td.classList.remove("quizCellSelected");
    selectedQuizCell = null;
}

function resetSingleCell(td){
    if(!td) return;
    const answer = td.dataset.answer || "";
    if(!answer) return;
    const options = parseAnswerOptions(answer).join("|");
    td.classList.remove("correct","wrong","discovered","toDiscover","quizCellSelected");
    td.dataset.tries = "0";
    td.dataset.correct = "0";
    td.dataset.firsttry = "0";
    td.dataset.discovered = "0";
    td.dataset.quizinput = "1";
    td.dataset.hintActive = "0";
    td.dataset.hintUsed = "0";
    td.classList.remove("hasHintBadge");
    td.innerHTML = `<input data-answer="${answer}" data-options="${options}" data-tries="0" data-maxtries="${savedConfig.maxCell||-1}" onkeydown="checkInput(event,this)">`;
    setupAutoEnter();
    selectedQuizCell = null;
}

openSettingsOverlay = function(){
    if(document.getElementById("settingsOverlay")) return;
    const overlay = document.createElement("div");
    overlay.id = "settingsOverlay";
    overlay.className = "dbOverlay";
    overlay.innerHTML = `
        <div class="dbPanel" style="max-width:680px; margin:10vh auto;">
            <div style="display:flex; align-items:center; gap:8px;">
                <h3 style="margin:0;">Ustawienia</h3>
                <button class="btn btn-danger" style="margin-left:auto;" onclick="document.getElementById('settingsOverlay').remove()">Zamknij</button>
            </div>
            <div class="settingsStack">
                <button class="btn btn-secondary settingsBtn" onclick="openShortcutsOverlay()">Skr√≥ty klawiszowe (podglƒÖd)</button>
                <button class="btn btn-secondary settingsBtn" onclick="openStyleOverlay()">Styl</button>
            </div>
        </div>`;
    document.body.appendChild(overlay);
};

openShortcutsOverlay = function(){
    if(document.getElementById("shortcutsOverlay")) return;
    const overlay = document.createElement("div");
    overlay.id = "shortcutsOverlay";
    overlay.className = "dbOverlay";
    overlay.innerHTML = `
        <div class="dbPanel" style="max-width:760px; margin:10vh auto;">
            <div style="display:flex; align-items:center; gap:8px;">
                <h3 style="margin:0;">Skr√≥ty klawiszowe</h3>
                <button class="btn btn-danger" style="margin-left:auto;" onclick="document.getElementById('shortcutsOverlay').remove()">Zamknij</button>
            </div>
            <div style="margin-top:10px;">
                <p><b>W Quizie</b></p>
                <p>\` + P - otwiera panel skr√≥t√≥w podpowiedzi</p>
                <p>\` + W - podpowied≈∫ wyrazowa (po panelu)</p>
                <p>\` + K - podpowied≈∫ kwadracikowa (po panelu)</p>
                <p>\` + O - odkrywa kom√≥rkƒô</p>
                <p>\` + R - resetuje kom√≥rkƒô</p>
                <p><b>W Edytorze Tabeli</b></p>
                <p>\` + K - panel kolumn (L/P/U)</p>
                <p>\` + W - panel wierszy (G/D/U)</p>
                <p>\` + N - wy≈ÇƒÖcza tryb</p>
                <p>\` + A - anuluje panel skr√≥t√≥w</p>
            </div>
        </div>`;
    document.body.appendChild(overlay);
};

openStyleOverlay = function(){
    if(document.getElementById("styleOverlay")) return;
    const overlay = document.createElement("div");
    overlay.id = "styleOverlay";
    overlay.className = "dbOverlay";
    overlay.innerHTML = `
        <div class="dbPanel" style="max-width:680px; margin:10vh auto;">
            <div style="display:flex; align-items:center; gap:8px;">
                <h3 style="margin:0;">Styl strony</h3>
                <button class="btn btn-danger" style="margin-left:auto;" onclick="document.getElementById('styleOverlay').remove()">Zamknij</button>
            </div>
            <div class="settingsStack">
                <div class="settingsLabel">Kolor strony</div>
                <select id="themeSelect" class="settingsSelect" onchange="setTheme(this.value)">
                    <option value="default">Domy≈õlny</option>
                    <option value="black">Czarny</option>
                    <option value="white">Bia≈Çy</option>
                    <option value="purple">Niebiesko-r√≥≈ºowy gradient</option>
                </select>
                <div class="settingsLabel">Efekt przycisk√≥w</div>
                <select id="liquidSelect" class="settingsSelect" onchange="setLiquidButtons(this.value==='on')">
                    <option value="on">Liquid Glass (iPhone)</option>
                    <option value="off">Bez Liquid Glass</option>
                </select>
            </div>
        </div>`;
    document.body.appendChild(overlay);
    const themeSelect = document.getElementById("themeSelect");
    const liquidSelect = document.getElementById("liquidSelect");
    if(themeSelect) themeSelect.value = uiPrefs.theme || "default";
    if(liquidSelect) liquidSelect.value = uiPrefs.liquid ? "on" : "off";
};

function showEditorShortcutMask(mode){
    hideEditorShortcutMask();
    editorShortcutMode = mode;
    const div = document.createElement("div");
    div.id = "editorShortcutMask";
    div.className = "shortcutMask";
    const txt = mode === "col"
        ? "Aby anulowaƒá kliknij ` + A<br>Mo≈ºliwe podopcje kolumn: L (lewa), P (prawa), U (usu≈Ñ)"
        : "Aby anulowaƒá kliknij ` + A<br>Mo≈ºliwe podopcje wierszy: G (g√≥ra), D (d√≥≈Ç), U (usu≈Ñ)";
    div.innerHTML = `<div class="shortcutMaskBox"><b>Tryb skr√≥t√≥w edytora aktywny</b><br><br>${txt}</div>`;
    document.body.appendChild(div);
}

function hideEditorShortcutMask(){
    document.getElementById("editorShortcutMask")?.remove();
    editorShortcutMode = null;
}

function showQuizHintShortcutMask(){
    hideQuizHintShortcutMask();
    if(!isQuizActive()) return;
    quizHintShortcutMode = true;
    const div = document.createElement("div");
    div.id = "quizHintShortcutMask";
    div.className = "shortcutMask";
    div.innerHTML = `<div class="shortcutMaskBox"><b>Podpowiedzi - skr√≥ty aktywne</b><br><br>Aby anulowaƒá kliknij \` + A<br>Wybierz typ: \` + W (wyrazowa) albo \` + K (kwadracikowa)</div>`;
    document.body.appendChild(div);
}

function hideQuizHintShortcutMask(){
    document.getElementById("quizHintShortcutMask")?.remove();
    quizHintShortcutMode = false;
}

const __oldRenderHintInCell = renderHintInCell;
renderHintInCell = function(td, type){
    __oldRenderHintInCell(td, type);
    td?.querySelectorAll(".hintSquare").forEach(sq=>{
        const old = sq.onclick;
        sq.onclick = (ev)=>{ ev.stopPropagation(); if(typeof old === "function") old(ev); };
    });
};

const __oldApplyHintTypeToCell = applyHintTypeToCell;
applyHintTypeToCell = function(td, type){
    __oldApplyHintTypeToCell(td, type);
    if(td){
        td.dataset.hintUsed = "1";
        td.dataset.hintActive = "1";
    }
};

const __oldStartQuiz = startQuiz;
startQuiz = function(){
    __oldStartQuiz();
    document.querySelectorAll("#tableContainer td[data-quizinput='1']").forEach(td=>{
        td.dataset.hintUsed = "0";
    });
};

const __oldUpdateCellClickHandlers = updateCellClickHandlers;
updateCellClickHandlers = function(){
    __oldUpdateCellClickHandlers();
    document.querySelectorAll("#tableContainer td").forEach(td=>{
        const old = td.onclick;
        td.onclick = (ev)=>{
            if(td.querySelector("input")){
                lastQuizCell = td;
                if(backtickHeld) setSelectedQuizCell(td);
            }
            if(typeof old === "function") old.call(td, ev);
        };
    });
};

const __oldCalculateStats = calculateStats;
calculateStats = function(){
    const quizCells = Array.from(document.querySelectorAll("#tableContainer td[data-quizinput='1']"));
    if(!quizCells.length) return __oldCalculateStats();

    let total = quizCells.length, correct = 0, firstTry = 0, errors = 0, usedDiscover = 0;
    let noHintTotal = 0, noHintCorrect = 0;
    let maxGood=0,maxBad=0,curGood=0,curBad=0;
    const errMap = [];

    quizCells.forEach(td=>{
        const ok = td.dataset.correct==="1" || td.classList.contains("correct");
        const t = parseInt(td.dataset.tries||"0");
        if(ok){
            correct++;
            if((td.dataset.firsttry||"0")==="1") firstTry++;
            curGood++; curBad=0; if(curGood>maxGood) maxGood=curGood;
        } else if(!ignoreWrongStreakStats){
            curBad++; curGood=0; if(curBad>maxBad) maxBad=curBad;
        }
        errors += t;
        if(t>0){
            const answerText = (td.dataset.answer || "").trim() || "(pusta)";
            errMap.push({k:answerText,v:t});
        }
        if(td.dataset.discovered==="1" || td.classList.contains("discovered")) usedDiscover++;
        if(td.dataset.hintUsed !== "1"){
            noHintTotal++;
            if(ok) noHintCorrect++;
        }
    });

    if(ignoreWrongStreakStats) maxBad = 0;
    const top = errMap.sort((a,b)=>b.v-a.v).slice(0,3).map((x,i)=>`${i+1}. ${x.k} - ${x.v} bledow`);
    const p1 = Math.round((correct/total)*100);
    const p2 = Math.round((firstTry/total)*100);
    const pNoHint = noHintTotal ? Math.round((noHintCorrect/noHintTotal)*100) : 0;
    const sec = Math.max(0,Math.floor((Date.now()-quizStartTime)/1000));
    const tm = `${Math.floor(sec/60)}:${String(sec%60).padStart(2,"0")}`;

    return `<p>Poprawnych odpowiedzi: ${correct}/${total} (${p1}%)</p>
            <p>Poprawnych za pierwszym razem: ${firstTry}/${total} (${p2}%)</p>
            <p>Skuteczno≈õƒá bez podpowiedzi: ${noHintCorrect}/${noHintTotal} (${pNoHint}%)</p>
            <p>Najwieksza passa poprawnych odpowiedzi: ${maxGood}</p>
            <p>Najwieksza passa blednych odpowiedzi: ${maxBad}</p>
            <p>Bledy globalne: ${errors}</p>
            <p>Ilosc uzyc odkryj wybranych: ${usedDiscover}</p>
            <p>Komorki z najwieksza iloscia bledow:<br>${top.length?top.join("<br>"):"Brak bledow"}</p>
            <p>Czas trwania quizu: ${tm}</p>`;
};

function handleGlobalShortcuts(e){
    if(e.code === "Backquote" || e.key === "`"){
        backtickHeld = true;
        if(hoveredQuizCell && hoveredQuizCell.isConnected && hoveredQuizCell.dataset.quizinput === "1"){
            setSelectedQuizCell(hoveredQuizCell);
        } else if(lastQuizCell && lastQuizCell.isConnected && lastQuizCell.querySelector("input")){
            setSelectedQuizCell(lastQuizCell);
        }
        e.preventDefault();
        return;
    }
    if(!backtickHeld) return;
    const key = String(e.key||"").toLowerCase();
    if(!key) return;

    if(isQuizActive()){
        if(key === "p"){ showQuizHintShortcutMask(); e.preventDefault(); return; }
        if(quizHintShortcutMode){
            if(key === "w"){ const td = getSelectedQuizCell(); if(td) applyHintTypeToCell(td, "1"); hideQuizHintShortcutMask(); e.preventDefault(); return; }
            if(key === "k"){ const td = getSelectedQuizCell(); if(td) applyHintTypeToCell(td, "2"); hideQuizHintShortcutMask(); e.preventDefault(); return; }
            if(key === "a"){ hideQuizHintShortcutMask(); e.preventDefault(); return; }
        }
        if(key === "o"){ revealSingleCell(getSelectedQuizCell()); e.preventDefault(); return; }
        if(key === "r"){ resetSingleCell(getSelectedQuizCell()); e.preventDefault(); return; }
    }

    if(isEditorActive()){
        if(key === "a"){ hideEditorShortcutMask(); e.preventDefault(); return; }
        if(key === "n"){ hideEditorShortcutMask(); setEditorMode("select"); e.preventDefault(); return; }
        if(key === "k"){ showEditorShortcutMask("col"); e.preventDefault(); return; }
        if(key === "w"){ showEditorShortcutMask("row"); e.preventDefault(); return; }
        if(editorShortcutMode === "col"){
            if(key === "l"){ setEditorMode("add-col-left"); hideEditorShortcutMask(); e.preventDefault(); return; }
            if(key === "p"){ setEditorMode("add-col-right"); hideEditorShortcutMask(); e.preventDefault(); return; }
            if(key === "u"){ setEditorMode("delete-col"); hideEditorShortcutMask(); e.preventDefault(); return; }
        }
        if(editorShortcutMode === "row"){
            if(key === "g"){ setEditorMode("add-row-up"); hideEditorShortcutMask(); e.preventDefault(); return; }
            if(key === "d"){ setEditorMode("add-row-down"); hideEditorShortcutMask(); e.preventDefault(); return; }
            if(key === "u"){ setEditorMode("delete-row"); hideEditorShortcutMask(); e.preventDefault(); return; }
        }
    }
}

document.addEventListener("keydown", handleGlobalShortcuts);
document.addEventListener("mousemove", (e)=>{
    if(!isQuizActive()) return;
    const td = e.target.closest("#tableContainer td[data-quizinput='1']");
    hoveredQuizCell = td || null;
    if(backtickHeld){
        if(hoveredQuizCell) setSelectedQuizCell(hoveredQuizCell);
        else clearSelectedQuizCell();
    }
});
document.addEventListener("keyup", (e)=>{
    if(e.code === "Backquote" || e.key === "`"){
        backtickHeld = false;
        clearSelectedQuizCell();
    }
});

const __oldBackToMenu = backToMenu;
backToMenu = function(){
    hideEditorShortcutMask();
    hideQuizHintShortcutMask();
    clearSelectedQuizCell();
    hoveredQuizCell = null;
    __oldBackToMenu();
};

const __oldClearAll = clearAll;
clearAll = function(){
    hideEditorShortcutMask();
    hideQuizHintShortcutMask();
    clearSelectedQuizCell();
    hoveredQuizCell = null;
    __oldClearAll();
};

loadUiPrefs();
applyUiPrefs();

</script>

</body>
</html>
